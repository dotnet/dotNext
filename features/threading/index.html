<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Asynchronous Locks | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Asynchronous Locks | .NEXT ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="asynchronous-locks">Asynchronous Locks</h1>

<p>Lock acquisition operation may blocks the caller thread. Reader/writer lock from .NET library doesn't have async versions of lock acquisition methods as well as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor">Monitor</a>. To avoid this, DotNext Threading library provides asynchronous non-blocking alternatives of these locks.</p>
<div class="CAUTION">
<h5>Caution</h5>
<p>Non-blocking and blocking locks are two different worlds. It is not recommended to mix these API in the same part of application. The lock acquired with blocking API located in <a class="xref" href="../../api/DotNext.Threading.Lock.html">Lock</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.monitor">Monitor</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim">ReaderWriteLockSlim</a> is not aware about the lock acquired asynchronously with <a class="xref" href="../../api/DotNext.Threading.AsyncLock.html">AsyncLock</a>, <a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncExclusiveLock</a> or <a class="xref" href="../../api/DotNext.Threading.AsyncReaderWriterLock.html">AsyncReaderWriterLock</a>. The only exception is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim">SemaphoreSlim</a> because it contains acquisition methods in blocking and non-blocking manner at the same time.</p>
</div>
<p>All non-blocking synchronization mechanisms are optimized in terms of memory allocations. If lock acquisitions are not caused in the same time from different application tasks running concurrently then heap allocation associated with waiting queue will not happen.</p>
<p>Asynchronous locks don't rely on the caller thread. The caller thread never blocks so there is no concept of lock owner thread. As a result, these locks are not reentrant.</p>
<p>It is hard to detect root cause of deadlocks occurred by asynchronous locks so use them carefully.</p>
<p><a class="xref" href="../../api/DotNext.Threading.AsyncLock.html">AsyncLock</a> is a unified representation of the all supported asynchronous locks:</p>
<ul>
<li>Exclusive lock</li>
<li><a class="xref" href="../../api/DotNext.Threading.AsyncSharedLock.html">Shared lock</a></li>
<li>Reader lock</li>
<li>Writer lock</li>
<li>Semaphore</li>
</ul>
<p>The only one synchronization object can be shared between blocking and non-blocking representations of the lock.</p>
<pre><code class="lang-csharp">using DotNext.Threading;
using System.Threading;

var semaphore = new SemaphoreSlim(1, 1);
var syncLock = Lock.Semaphore(semaphore);
var asyncLock = AsyncLock.Semaphore(semaphore);

//thread #1
using (syncLock.Acquire())
{

}

//thread #2
using (await asyncLock.AcquireAsync(CancellationToken.None))
{

}
</code></pre>
<p><code>AsyncLock</code> implementing <a href="https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable">IAsyncDisposable</a> interface for graceful shutdown if supported by underlying lock type. The following lock types have graceful shutdown:</p>
<ul>
<li><a href="exclusive.html">AsyncExclusiveLock</a></li>
<li><a href="rwlock.html">AsyncReaderWriterLock</a></li>
<li><a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncSharedLock</a></li>
<li><a href="exchanger.html">AsyncExchanger</a></li>
</ul>
<p>Details of graceful shutdown described in related articles.</p>
<h1 id="built-in-readerwriter-synchronization">Built-in Reader/Writer Synchronization</h1>
<p>Exclusive lock may not be applicable due to performance reasons for some data types. For example, exclusive lock for dictionary or list is redundant because there are two consumers of these objects: writers and readers.</p>
<p>.NEXT Threading library provides several extension methods for more granular control over synchronization of any reference type:</p>
<ul>
<li><code>AcquireReadLockAsync</code> acquires reader lock asynchronously</li>
<li><code>AcquireWriteLockAsync</code> acquires exclusive lock asynchronously</li>
</ul>
<p>These methods allow to turn any thread-unsafe object into thread-safe object with precise control in context of multithreading access.</p>
<pre><code class="lang-csharp">using DotNext.Threading;
using System.Text;

var builder = new StringBuilder();

//reader
using (builder.AcquireReadLockAsync(CancellationToken.None))
{
    Console.WriteLine(builder.ToString());
}

//writer
using (builder.AcquireWriteLockAsync(CancellationToken.None))
{
    builder.Append(&quot;Hello, world!&quot;);
}
</code></pre>
<p>For more information check extension methods inside of <a class="xref" href="../../api/DotNext.Threading.LockAcquisition.html">AsyncLockAcquisition</a> class.</p>
<h1 id="custom-synchronization-primitive">Custom synchronization primitive</h1>
<p><a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer-1.html">QueuedSynchronizer&lt;TContext&gt;</a> provides low-level infrastructure for writing custom synchronization primitives for asynchronous code. It uses the same <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">synchronization engine</a> as other primitives shipped with the library: <a class="xref" href="../../api/DotNext.Threading.AsyncExclusiveLock.html">AsyncExclusiveLock</a>, <a class="xref" href="../../api/DotNext.Threading.AsyncReaderWriterLock.html">AsyncReaderWriterLock</a>, etc. The following example demonstrates how to write custom async-aware reader-writer lock:</p>
<pre><code class="lang-csharp">using DotNext.Threading;

// bool indicates lock type:
// false - read lock
// true - write lock
class MyExclusiveLock : QueuedSynchronizer&lt;bool&gt;
{
    // = 0 - no lock acquired
    // &gt; 0 - read lock
    // &lt; 0 - write lock
    private int readersCount;

    public MyExclusiveLock()
        : base(null)
    {
    }

    public ValueTask AcquireReadLockAsync(CancellationToken token)
        =&gt; base.AcquireAsync(false, token);

    public void ReleaseReadLock(CancellationToken token)
        =&gt; base.Release(false);

    public ValueTask AcquireWriteLockAsync(CancellationToken token)
        =&gt; base.AcquireAsync(true, token);

    public void ReleaseWriteLock()
        =&gt; base.Release(true);

    // write lock cannot be acquired if there is at least one read lock, or single write lock
    protected override bool CanAcquire(bool writeLock)
        =&gt; writeLock ? readersCount is 0 : readersCount &gt;= 0;

    protected override void AcquireCore(bool writeLock)
        =&gt; readersCount = writeLock ? -1 : readersCount + 1;

    protected override void ReleaseCore(bool writeLock)
        =&gt; readersCount = writeLock ? 0 : readersCount - 1;
}
</code></pre>
<h1 id="diagnostics">Diagnostics</h1>
<p>All synchronization primitives for asynchronous code mostly derive from <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">QueuedSynchronized</a> class that exposes a set of important diagnostics counters:</p>
<ul>
<li><code>LockContentionCounter</code> allows to measure a number of lock contentions detected in the specified time period</li>
<li><code>LockDurationCounter</code> allows to measure the amount of time spend by the suspended caller in the suspended state</li>
</ul>
<h1 id="debugging">Debugging</h1>
<p>In addition to diagnostics tools, <a class="xref" href="../../api/DotNext.Threading.QueuedSynchronizer.html">QueuedSynchronized</a> and all its derived classes support a rich set of debugging tools:</p>
<ul>
<li><code>TrackSuspendedCallers</code> method allows to enable tracking information about suspended caller. This method has effect only when building project using <code>Debug</code> configuration</li>
<li><code>SetCallerInformation</code> method allows to associate information with the caller if it will be suspended during the call of <code>WaitAsync</code>. This method has effect only when building project using <code>Debug</code> configuration</li>
<li><code>GetSuspendedCallers</code> method allows to capture a list of all suspended callers. The method is working only if tracking is enabled via <code>TrackSuspendedCallers</code> method. Typically, this method should be used in debugger's <em>Watch</em> window when all threads are paused</li>
</ul>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/index.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
