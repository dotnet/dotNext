<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Async Reader/Writer Lock | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Async Reader/Writer Lock | .NEXT ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="async-readerwriter-lock">Async Reader/Writer Lock</h1>

<p><a class="xref" href="../../api/DotNext.Threading.AsyncReaderWriterLock.html">AsyncReaderWriterLock</a> is a non-blocking asynchronous alternative to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim">ReaderWriteLockSlim</a> with the same semantics.</p>
<p>This class supports methods to determine whether locks are held or contended. These methods are designed for monitoring system state, not for synchronization control.</p>
<p>The reader lock and writer lock both support interruption during lock acquisition using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken">CancellationToken</a>.</p>
<pre><code class="lang-csharp">using System.Threading;
using DotNext.Threading;

var rwlock = new AsyncReaderWriterLock();

await rwlock.EnterReadLockAsync(CancellationToken.None);
try
{
    //reader stuff here
}
finally
{
    rwlock.Release();
}

await rwlock.EnterWriteLockAsync(TimeSpan.FromSecond(2));
try
{
    //writer stuff here
}
finally
{
    rwlock.Release();
}

await rwlock.UpgradeToWriteLockAsync(TimeSpan.FromSecond(2), CancellationToken.None);
try
{
    //writer stuff here
}
finally
{
    rwlock.DowngradeFromWriteLock();
}

//or with 'using statement'
using (await rwlock.AcquireReadLockAsync(CancellationToken.None))
{
    //reader stuff here
}

using (await rwlock.AcquireWriteLockAsync(TimeSpan.FromSecond(2)))
{
    //writer stuff here
}
</code></pre>
<p>Exclusive lock should be destroyed if no longer needed by calling <code>Dispose</code> method which is not thread-safe.</p>
<p>Behavior of <code>UpgradeToWriteLockAsync</code> and <code>DowngradeFromWriteLock</code> methods is the same as in <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock">ReaderWriterLock</a>. You need to be in the read lock to call the upgrade. After calling of <code>DowngradeFromWriteLock</code> method the current flow keeping the read lock so you need to call <code>Release</code> method to release the lock completely.</p>
<h2 id="acquisition-order">Acquisition Order</h2>
<p>This lock does not impose a reader or writer preference ordering for lock access. However, it respects fairness policy. It means that callers contend for entry using an approximately arrival-order policy. When the currently held lock is released either the longest-waiting single writer will be assigned the write lock, or if there is a group of readers waiting longer than all waiting writers, that group will be assigned the read lock.</p>
<p>A caller that tries to acquire a read lock (non-reentrant) will enqueued if either the write lock is held, or there is a waiting writer. The caller will not acquire the read lock until after the oldest currently waiting writer has acquired and released the write lock. Of course, if a waiting writer abandons its wait, leaving one or more readers as the longest waiters in the queue with the write lock free, then those readers will be assigned the read lock.</p>
<p>A caller that tries to acquire a write lock (non-reentrant) will block unless both the read lock and write lock are free (which implies there are no waiters).</p>
<h2 id="graceful-shutdown">Graceful Shutdown</h2>
<p><code>Dispose</code> method is not thread-safe and may cause unpredictable behavior if called on the lock which was acquired previously. This is happening because the method doesn't wait for the lock to be released. Starting with version <em>2.6.0</em> this type of lock implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.iasyncdisposable">IAsyncDisposable</a> interface and provides a way for graceful shutdown. <code>DisposeAsync</code> behaves in the following way:</p>
<ul>
<li>If lock is not acquired then completes synchronously</li>
<li>If lock is acquired then suspends the caller and wait when it will be released, then dispose the lock</li>
</ul>
<h2 id="synchronous-acquisition">Synchronous acquisition</h2>
<p>The class exposes <code>TryEnterReadLock(TimeSpan)</code> and <code>TryEnterWriteLock(TimeSpan)</code> blocking methods that can be used by synchronous callers. The method allows to perform mixed synchronization for synchronous and asynchronous code at the same time.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/threading/rwlock.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
