<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Raft | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Raft | .NEXT ">
    <meta name="generator" content="docfx 2.59.0.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="raft">Raft</h1>

<p>Raft is a consensus algorithm suitable for building <em>master-replica</em> clusters with the following features:</p>
<ul>
<li>Linearizability of operations</li>
<li>Data consistency (weak or strong)</li>
<li>Election of the leader node responsible for processing <em>write</em> operations</li>
<li>Replication</li>
<li>Cluster configuration management</li>
</ul>
<p>The core of Raft implementation is <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster-1.html">RaftCluster&lt;TMember&gt;</a> class which contains transport-agnostic implementation of Raft algorithm. First-class support of Raft in ASP.NET Core as well as other features are based on this class.</p>
<h1 id="consensus">Consensus</h1>
<p>Correctness of consensus algorithm is tightly coupled with Write-Ahead Log defined via <code>AuditTrail</code> property of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface or via Dependency Injection. If your application requires only consensus without replication of real data then <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.ConsensusOnlyState.html">ConsensusOnlyState</a> implementation is used. Note that this implementation is used by default as well. It is lighweight and fast. However it doesn't store state on disk. Consider to use <a href="wal.html">persistent WAL</a> as fully-featured persistent log for Raft.</p>
<h1 id="state-recovery">State Recovery</h1>
<p>The underlying state machine can be reconstruced at application startup using <code>InitializeAsync</code> method provided by implementation of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface. Usually, this method is called by .NEXT infrastructure automatically.</p>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.MemoryBasedStateMachine.html">MemoryBasedStateMachine</a> class exposes <code>ReplayAsync</code> method to do this manually. Read more about persistent Write-Ahead Log for Raft <a href="wal.html">here</a>.</p>
<h1 id="client-interaction">Client Interaction</h1>
<p><a href="https://github.com/ongardie/dissertation/tree/master/clients">Chapter 6</a> of Diego's dissertation contains recommendations about interaction between external client and cluster nodes. Raft implementation provided by .NEXT doesn't implement client session control as described in the paper. However, it offers all necessary tools for that:</p>
<ol>
<li><code>IPersistentState.EnsureConsistencyAsync</code> method waits until last committed entry is from leader's term</li>
<li><code>IReplicationCluster.ForceReplicationAsync</code> method initiates a new round of heartbeats and waits for reply from the majority of nodes</li>
<li><code>IRaftCluster.Lease</code> property to gets the lease that can be used for linearizable read</li>
<li><code>IRaftCluster.ReplicateAsync</code> method to append, replicate and commit the log entry. Useful for implementing <em>write</em> operations</li>
<li><code>IRaftCluster.ApplyReadBarrierAsync</code> method to insert a barrier to achieve linearizable read</li>
<li><code>IRaftCluster.LeadershipToken</code> property provides <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken">CancellationToken</a> that represents a leadership state. If the local node is a leader then the token is in non-signaled state. If the local node is a follower node then the token is in canceled state. If local node is downgrading from the leader to the follower state then the token will be moved to the canceled state. This token is useful when implementing <em>write</em> operations and allow to abort asynchronous operation in case of downgrade</li>
</ol>
<p>Elimination of duplicate commands received from clients should be implemented manually because basic framework is not aware about underlying network transport.</p>
<h2 id="linearizability">Linearizability</h2>
<p><a href="https://en.wikipedia.org/wiki/Linearizability">Linearizability</a> requires the results of a read to reflect
a state of the system sometime after the read was initiated; each read must at least return the results
of the latest committed write. For instance, if the client performs <em>Write</em> operation on variable <em>A</em> and immediately requests variable <em>A</em> back then <em>A</em> must have the value which is equal to the value provided by <em>Write</em> operation or more recent value. Without the linearizability, the client can see stale value of <em>A</em>. In other words, there is no guarantee that the client will able to see the result of its own <em>Write</em> operation. A system that allowed stale reads would only provide serializability, which is a weaker form of consistency.</p>
<p>Linearizable read can be achieved in Raft naturally. <em>Read</em> operation can be performed on leader or follower nodes.</p>
<p><code>IRaftCluster.Lease</code> property exposes leadership lease than quarantees that the leader cannot be changed during that lease. This method of provoding linearizability doesn't require extra round of heartbeats. As a result, this is the most performant way to process read-only queries. However, the duration of the lease depends on <em>clockDriftBound</em>. Here's the citation from Raft paper:</p>
<blockquote>
<p>The lease approach assumes a bound on clock drift across servers (over a given time period, no server’s clock increases more than this bound times any other). Discovering and maintaining this bound might present operational challenges (e.g., due to scheduling and garbage collection pauses, virtual machine migrations, or clock rate adjustments for time synchronization). If the assumptions are violated, the system could return arbitrarily stale information.</p>
</blockquote>
<p>Lease approach can be used only if processing of all read-only queries performing by the leader node.</p>
<p>Another approach is to use <em>read barrier</em>. The barrier is provided by <code>IRaftCluster.ApplyReadBarrierAsync</code> method. It allows to process read-only queries by follower nodes. In case of follower node, the method instructs leader node to execute a new round of heartbeats (with help of <code>ForceReplicationAsync</code> method). The follower waits for its state machine to advance at least as far as the index of the last committed log entry on the leader node. These actions are enough to satisfy linearizability. As you can see, this approach leads to extra overhead caused by network communication.</p>
<p>Lease and read barrier are mechanisms for linearizable reads provided out-of-the-box. However, it's possible to use any other approach. For instance, the server respond with the commit index for each <em>Write</em> request. The client can update and remember this value locally and provide it with read-only query. When <em>Read</em> request is received, the server may call <code>IPersistentState.WaitForCommitAsync</code> to ensure that the log contains the index of the last committed log entry by the client.</p>
<h1 id="node-bootstrapping">Node Bootstrapping</h1>
<p>The node can be started in two modes:</p>
<ul>
<li><strong>Cold Start</strong> means that the starting node is the initial node in the cluster. In that case, the node adds itself to the cluster configuration in committed state.</li>
<li><strong>Announcement</strong> means that the starting node must be announced through the leader, added to the cluster configuration and committed by the majority of nodes. In that case the node is started in <em>Standby</em> mode and waits until it will be added to the configuration by leader node and replicated to the that node</li>
</ul>
<p>The node is started using <code>StartAsync</code> method of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster-1.html">RaftCluster&lt;TMember&gt;</a> class doesn't mean that the node is ready to serve client requests. To ensure that the node is bootstrapped correctly, use <em>Readiness Probe</em>. The probe is provided through <code>Readiness</code> property of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftCluster.html">IRaftCluster</a> interface.</p>
<h1 id="cluster-configuration-management">Cluster Configuration Management</h1>
<p>Raft supports cluster configuration management out-of-the-box. Cluster configuration is a set of cluster members consistently stored on the nodes. The leader node is responsible for processing amendments of the configuration and replicating the modified configuration to follower nodes. Thus, a list of cluster members is always in consistent state.</p>
<p>The configuration can be in two states:</p>
<ul>
<li><em>Active</em> configuration which is used by the leader node for sending heartbeats. This type of configuration is always acknowledged by the majority of nodes and, as a result, the same on every node in the cluster</li>
<li><em>Proposed</em> configuration which is created by leader node as a response to configuration change. This type of configuration must be replicated and confirmed by the majority of nodes to be transformed into <em>Active</em> configuration.</li>
</ul>
<p>Proposed configuration is similar to uncommitted log entries in Raft log. Due to simplicity, the proposed configuration can be created using the following operations:</p>
<ul>
<li>Add a new member</li>
<li>Remove the existing member</li>
</ul>
<p>It's not possible to remove or add multiple members at a time. Instead, you need to add or remove single member and replicate that change. When the proposed configuration is accepted by the majority of nodes, the leader node turns that configuration into the active configuration.</p>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.Membership.IClusterConfigurationStorage.html">IClusterConfigurationStorage</a> interface is responsible for maintaining cluster configuration. There are two possible storages:</p>
<ul>
<li><em>In-memory</em> storage that stores configuration in the memory. Restarting the node leads to configuration loss</li>
<li><em>Persistent</em> storage that stores configuration in the file system</li>
</ul>
<p>When a new node is added, it passes through warmup procedure. The leader node attempts to replicate as much as possible log entries to the added node. The number of rounds for catch up can be configured by <code>WarmupRounds</code> configuration property. When the leader node decided that the new node is in sync then it adds the address of that node to the proposed configuration. When the proposed configuration becomes the active configuration, readiness probe of the added node turning into the signaled state.</p>
<h1 id="network-transport">Network Transport</h1>
<p>.NEXT supports the following network transports:</p>
<ul>
<li>HTTP 1.1, HTTP 2.0 and HTTP 3.0</li>
<li>TCP transport</li>
<li>UDP transport</li>
</ul>
<p>TCP and UDP network transports shipped with <code>DotNext.Net.Cluster</code> library without heavyweight dependencies such as ASP.NET Core or DotNetty. The library provides specialized <a href="https://en.wikipedia.org/wiki/Application_layer">application protocol</a> on top of these transports which is binary protocol, highly optimized for Raft purposes and provide maximum bandwidth in contrast to HTTP. However, additional features for cluster programming are limited:</p>
<ul>
<li>General-purpose messaging between nodes is not supported via <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> interface</li>
</ul>
<p>Cluster programming model using TCP and UDP transports is unified and exposed via <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster.html">RaftCluster</a> class. The following example demonstrates usage of this class:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;

RaftCluster.NodeConfiguration config = ...;//configuration of the local node
//configuring members in the cluster
config.Members.Add(new IPEndPoint(IPAddress.Loopback), 3262);
config.Members.Add(new IPEndPoint(IPAddress.Loopback), 3263);

using var cluster = new RaftCluster(config);
await cluster.StartAsync(CancellationToken.None); //starts hosting of the local node
//the code for working with cluster instance
await cluster.StopAsync(CancellationToken.None);    //stops hosting of the local node
</code></pre>
<p>The configuration of the local node depends on chosen network transport. <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster.NodeConfiguration.html">NodeConfiguration</a> abstract class exposes common properties for both transports:</p>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Metrics</td>
<td>No</td>
<td><strong>null</strong></td>
<td>Allows to specify custom metrics collector</td>
</tr>
<tr>
<td>PublicEndPoint</td>
<td>No</td>
<td>The same as <code>HostEndPoint</code></td>
<td>Allows to specify real IP address of the host where cluster node launched. Usually it is needed when node executed inside of Docker container. If this parameter is not specified then cluster node may fail to detect itself because network interfaces inside of Docker container have different addresses in comparison with real host network interfaces</td>
</tr>
<tr>
<td>Partitioning</td>
<td>No</td>
<td>false</td>
<td><code>true</code> if partitioning supported. In this case, each cluster partition may have its own leader, i.e. it is possible to have more that one leader for external observer. However, single partition cannot have more than 1 leader. <code>false</code> if partitioning is not supported and only one partition with majority of nodes can have leader. Note that cluster may be totally unavailable even if there are operating members presented</td>
</tr>
<tr>
<td>HeartbeatThreshold</td>
<td>No</td>
<td>0.5</td>
<td>Specifies frequency of heartbeat messages generated by leader node to inform follower nodes about its leadership. The range is (0, 1). The lower the value means that the messages are generated more frequently and vice versa</td>
</tr>
<tr>
<td>LowerElectionTimeout, UpperElectionTimeout</td>
<td>No</td>
<td>150</td>
<td>Defines range for election timeout (in milliseconds) which is picked randomly inside of it for each cluster member. If cluster node doesn't receive heartbeat from leader node during this timeout then it becomes a candidate and start a election. The recommended value for  <em>upperElectionTimeout</em> is <code>2  X lowerElectionTimeout</code></td>
</tr>
<tr>
<td>PipeConfig</td>
<td>No</td>
<td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipeoptions.default">PipeOptions.Default</a></td>
<td>The configuration of I/O pipeline used for passing bytes between application and network transport</td>
</tr>
<tr>
<td>MemoryAllocator</td>
<td>No</td>
<td>Memory pool from <em>PipeConfig</em> property</td>
<td>Memory allocator used to allocate memory for network packets</td>
</tr>
<tr>
<td>Metadata</td>
<td>No</td>
<td>Empty dictionary</td>
<td>A set of metadata properties associated with the local node</td>
</tr>
<tr>
<td>TimeToLive</td>
<td>No</td>
<td>64</td>
<td>Time To Live (TTL) value of Internet Protocol (IP) packets</td>
</tr>
<tr>
<td>RequestTimeout</td>
<td>No</td>
<td><em>UpperElectionTimeout</em></td>
<td>Defines request timeout for accessing cluster members across the network</td>
</tr>
<tr>
<td>LoggerFactory</td>
<td>No</td>
<td><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.abstractions.nullloggerfactory.instance">NullLoggerFactory.Instance</a></td>
<td>The logger factory</td>
</tr>
<tr>
<td>BufferingOptions</td>
<td>No</td>
<td><strong>null</strong></td>
<td>Enables buffering of log entries when transferring over the wire. If defined, receiver creates a buffered copy of the log entries and the snapshot before appending them to the log. It increases response time during replication but reduces the potential lock contention in WAL between replication process and other writers</td>
</tr>
<tr>
<td>Standby</td>
<td>No</td>
<td><strong>false</strong></td>
<td><strong>true</strong> to prevent election of the cluster member as a leader. It's useful to configure the nodes available for read-only operations only</td>
</tr>
<tr>
<td>ConfigurationStorage</td>
<td>Yes</td>
<td>N/A</td>
<td>Represents a storage for the list of cluster members. You can use <code>UseInMemoryConfigurationStorage</code> method for testing purposes</td>
</tr>
<tr>
<td>Announcer</td>
<td>No</td>
<td><strong>null</strong></td>
<td>A delegate of type <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.Membership.ClusterMemberAnnouncer-1.html">ClusterMemberAnnouncer&lt;TAddress&gt;</a> that can be used to announce a new node on leader</td>
</tr>
<tr>
<td>WarmupRounds</td>
<td>No</td>
<td>10</td>
<td>The numbers of rounds used to warmup a fresh node which wants to join the cluster</td>
</tr>
<tr>
<td>ColdStart</td>
<td>No</td>
<td><strong>true</strong></td>
<td><strong>true</strong> to start the initial node in the cluster. In case of cold start, the node doesn't announce itself. <strong>false</strong> to start the node in standby node and wait for announcement</td>
</tr>
</tbody>
</table>
<p>By default, all transport bindings for Raft use in-memory configuration storage.</p>
<p>Cluster configuration management is represented by the following methods declared in <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster.html">RaftCluster</a> class:</p>
<ul>
<li><code>AddMemberAsync</code> to add and catch up a new node</li>
<li><code>RemoveMemberAsync</code> to remove the existing node</li>
</ul>
<p><code>AddMemberAsync</code> can be called by deployment script, manually by the administrator or through <em>Announcer</em>. <code>RemoveMemberAsync</code> can be called as a part of graceful shutdown (planned deprovisioning) or manually by the administrator.</p>
<h2 id="http-transport-and-aspnet-core">HTTP transport and ASP.NET Core</h2>
<p><code>DotNext.AspNetCore.Cluster</code> library is an extension for ASP.NET Core for writing microservices and supporting the following features:</p>
<ol>
<li>Messaging is fully supported and organized through HTTP 1.1, HTTP 2.0 or HTTP 3.0 protocol including TLS</li>
<li>Replication is fully supported</li>
<li>Consensus is fully supported and based on Raft algorithm</li>
<li>Tight integration with ASP.NET Core ecosystem such as Dependency Injection and Configuration Object Model</li>
<li>Compatible with Kestrel or any other third-party web host</li>
<li>Detection of changes in the list of cluster nodes via configuration</li>
</ol>
<p>These extensions are located in <code>DotNext.Net.Cluster.Consensus.Raft.Http</code> namespace.</p>
<p>This implementation is WAN friendly because it uses reliable network transport and supports TLS. It is good choice if your cluster nodes communicate over Internet or any other unreliable network. However, HTTP leads to performance and traffic overhead. Moreover, the library depends on ASP.NET Core.</p>
<p>Web application is treated as cluster node. The following example demonstrates how to turn ASP.NET Core application into cluster node:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler();	//informs that processing pipeline should handle Raft-specific requests
    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.UsePersistentConfigurationStorage(&quot;/path/to/folder&quot;);
    }
}

IHost host = new HostBuilder()
    .ConfigureWebHost(webHost =&gt; webHost
        .UseKestrel(options =&gt; options.ListenLocalhost(80))
        .UseStartup&lt;Startup&gt;()
    )
    .JoinCluster()  //registers all necessary services required for normal cluster node operation
    .Build();
</code></pre>
<p>Note that <code>JoinCluster</code> method should be called after <code>ConfigureWebHost</code>. Otherwise, the behavior of this method is undefined.</p>
<p><code>JoinCluster</code> method has overloads that allow to specify custom configuration section containing the configuration of the local node.</p>
<p><code>UseConsensusProtocolHandler</code> method should be called before registration of any authentication/authorization middleware.</p>
<p><code>UsePersistentConfigurationStorage</code> allows to configure a persistent storage for the cluster configuration. Additionally, you can use <code>UseInMemoryConfigurationStorage</code> method and keep the configuration in the memory. However, it's not recommended for production use.</p>
<h3 id="dependency-injection">Dependency Injection</h3>
<p>The application may request the following services from ASP.NET Core DI container:</p>
<ul>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.ICluster.html">ICluster</a></li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftCluster.html">IRaftCluster</a> represents Raft-specific version of <code>ICluster</code> interface</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> for point-to-point messaging between nodes</li>
<li><a class="xref" href="../../api/DotNext.Net.IPeerMesh-1.html">IPeerMesh&lt;IRaftClusterMember&gt;</a> for tracking changes in cluster membership</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster-1.html">IReplicationCluster&lt;IRaftLogEntry&gt;</a> to work with audit trail used for replication. <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftLogEntry.html">IRaftLogEntry</a> is Raft-specific representation of the record in the audit trail</li>
<li><a class="xref" href="../../api/DotNext.Net.Cluster.Replication.IReplicationCluster.html">IReplicationCluster</a> to work with audit trail in simplified manner</li>
</ul>
<h3 id="configuration">Configuration</h3>
<p>The application should be configured properly to work as a cluster node. The following JSON represents the example of configuration:</p>
<pre><code class="lang-json">{
	&quot;partitioning&quot; : false,
	&quot;lowerElectionTimeout&quot; : 150,
	&quot;upperElectionTimeout&quot; : 300,
	&quot;metadata&quot; :
	{
		&quot;key&quot;: &quot;value&quot;
	},
	&quot;requestJournal&quot; :
	{
		&quot;memoryLimit&quot;: 5,
		&quot;expiration&quot;: &quot;00:00:10&quot;,
		&quot;pollingInterval&quot; : &quot;00:01:00&quot;
	},
	&quot;resourcePath&quot; : &quot;/cluster-consensus/raft&quot;,
    &quot;clientHandlerName&quot; : &quot;raftClient&quot;,
	&quot;port&quot; : 3262,
	&quot;heartbeatThreshold&quot; : 0.5,
    &quot;requestTimeout&quot; : &quot;00:01:00&quot;,
    &quot;rpcTimeout&quot; : &quot;00:00:150&quot;,
    &quot;keepAliveTimeout&quot;: &quot;00:02:00&quot;,
    &quot;openConnectionForEachRequest&quot; : false,
    &quot;clockDriftBound&quot; : 1.0,
    &quot;coldStart&quot; : true,
    &quot;standby&quot; : false,
    &quot;warmupRounds&quot; : 10,
    &quot;protocolVersion&quot; : &quot;auto&quot;,
    &quot;protocolVersionPolicy&quot; : &quot;RequestVersionOrLower&quot;,
}
</code></pre>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>partitioning</td>
<td>No</td>
<td>false</td>
<td><code>true</code> if partitioning supported. In this case, each cluster partition may have its own leader, i.e. it is possible to have more that one leader for external observer. However, single partition cannot have more than 1 leader. <code>false</code> if partitioning is not supported and only one partition with majority of nodes can have leader. Note that cluster may be totally unavailable even if there are operating members presented</td>
</tr>
<tr>
<td>lowerElectionTimeout, upperElectionTimeout</td>
<td>No</td>
<td>150, 300</td>
<td>Defines range for election timeout (in milliseconds) which is picked randomly inside of it for each cluster member. If cluster node doesn't receive heartbeat from leader node during this timeout then it becomes a candidate and start a election. The recommended value for  <em>upperElectionTimeout</em> is <code>2  X lowerElectionTimeout</code></td>
</tr>
<tr>
<td>metadata</td>
<td>No</td>
<td>empty dictionary</td>
<td>A set of key/value pairs to be associated with cluster node. The metadata is queriable through <code>IClusterMember</code> interface</td>
</tr>
<tr>
<td>openConnectionForEachRequest</td>
<td>No</td>
<td>false</td>
<td><code>true</code> to create TCP connection every time for each outbound request. <code>false</code> to use HTTP KeepAlive</td>
</tr>
<tr>
<td>clientHandlerName</td>
<td>No</td>
<td>raftClient</td>
<td>The name to be passed into <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a> to create <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessageinvoker">HttpMessageInvoker</a> used by Raft client code</td>
</tr>
<tr>
<td>resourcePath</td>
<td>No</td>
<td>/cluster-consensus/raft</td>
<td>The relative path to the endpoint responsible for handling internal Raft messages</td>
</tr>
<tr>
<td>requestJournal:memoryLimit</td>
<td>No</td>
<td>10</td>
<td>The maximum amount of memory (in MB) utilized by internal buffer used to track duplicate messages</td>
</tr>
<tr>
<td>requestJournal:expiration</td>
<td>No</td>
<td>00:00:10</td>
<td>The eviction time of the record containing unique request identifier</td>
</tr>
<tr>
<td>requestJournal:pollingInterval</td>
<td>No</td>
<td>00:01:00</td>
<td>Gets the maximum time after which the buffer updates its memory statistics</td>
</tr>
<tr>
<td>heartbeatThreshold</td>
<td>No</td>
<td>0.5</td>
<td>Specifies frequency of heartbeat messages generated by leader node to inform follower nodes about its leadership. The range is (0, 1). The lower the value means that the messages are generated more frequently and vice versa.</td>
</tr>
<tr>
<td>protocolVersion</td>
<td>No</td>
<td>auto</td>
<td>HTTP protocol version to be used for the communication between members. Possible values are <code>auto</code>, <code>http1</code>, <code>http2</code>, <code>http3</code></td>
</tr>
<tr>
<td>protocolVersionPolicy</td>
<td>No</td>
<td>RequestVersionOrLower</td>
<td>Specifies behaviors for selecting and negotiating the HTTP version for a request. Possible values are <code>RequestVersionExact</code>, <code>RequestVersionOrHigher</code>, <code>RequestVersionOrLower</code></td>
</tr>
<tr>
<td>requestTimeout</td>
<td>No</td>
<td><code>upperElectionTimeout</code></td>
<td>Request timeout used to access cluster members across the network using HTTP client</td>
</tr>
<tr>
<td>rpcTimeout</td>
<td>No</td>
<td><code>upperElectionTimeout</code> / 2</td>
<td>Request timeout used to send Raft-specific messages to cluster members. Must be less than or equal to <em>requestTimeout</em> parameter</td>
</tr>
<tr>
<td>standby</td>
<td>No</td>
<td>false</td>
<td><strong>true</strong> to prevent election of the cluster member as a leader. It's useful to configure the nodes available for read-only operations only</td>
</tr>
<tr>
<td>coldStart</td>
<td>No</td>
<td>true</td>
<td><strong>true</strong> to start the initial node in the cluster. In case of cold start, the node doesn't announce itself. <strong>false</strong> to start the node in standby node and wait for announcement</td>
</tr>
<tr>
<td>clockDriftBound</td>
<td>No</td>
<td>1.0</td>
<td>A bound on clock drift across servers. This value is used to calculate the leader lease duration. The lease can be obtained via <code>IRaftCluster.Lease</code> property. The lease approach assumes a bound on clock drift across servers: over a given time period, no server’s clock increases more than this bound times any other</td>
</tr>
<tr>
<td>warmupRounds</td>
<td>No</td>
<td>10</td>
<td>The numbers of rounds used to warmup a fresh node which wants to join the cluster</td>
</tr>
</tbody>
</table>
<p><code>requestJournal</code> configuration section is rarely used and useful for high-load scenarios only.</p>
<p>Choose <code>lowerElectionTimeout</code> and <code>upperElectionTimeout</code> according with the quality of your network. If these values are small then you'll get a frequent leader re-elections.</p>
<h3 id="controlling-node-lifetime">Controlling node lifetime</h3>
<p>The service implementing <code>IRaftCluster</code> is registered as singleton service. It starts receiving Raft-specific messages immediately. Therefore, you can loose some events raised by the service such as <code>LeaderChanged</code> at starting point. To avoid that, you can implement <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IClusterMemberLifetime.html">IClusterMemberLifetime</a> interface and register implementation as a singleton.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using System.Collections.Generic;

internal sealed class MemberLifetime : IClusterMemberLifetime
{
	private static void LeaderChanged(ICluster cluster, IClusterMember leader) {}

	void IClusterMemberLifetime.OnStart(IRaftCluster cluster, IDictionary&lt;string, string&gt; metadata)
	{
		metadata[&quot;key&quot;] = &quot;value&quot;;
		cluster.LeaderChanged += LeaderChanged;
	}

	void IClusterMemberLifetime.OnStop(IRaftCluster cluster)
	{
		cluster.LeaderChanged -= LeaderChanged;
	}
}
</code></pre>
<p>Additionally, the hook can be used to modify metadata of the local cluster member.</p>
<h3 id="http-client-behavior">HTTP Client Behavior</h3>
<p>HTTP binding for Raft uses <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient">HttpClient</a> for communication between cluster nodes. The client itself delegates all operations to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessagehandler">HttpMessageHandler</a>. It's not recommended to use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclienthandler">HttpClientHandler</a> because it has inconsistent behavior on different platforms. For instance, on Linux it invokes <em>libcurl</em>. Raft implementation uses <code>Timeout</code> property of <code>HttpClient</code> to establish request timeout. It's always defined as <code>upperElectionTimeout</code> by .NEXT infrastructure. To demonstrate the inconsistent behavior let's introduce three cluster nodes: <em>A</em>, <em>B</em> and <em>C</em>. <em>A</em> and <em>B</em> have been started except <em>C</em>:</p>
<ul>
<li>On Windows the leader will not be elected even though the majority is present - 2 of 3 nodes are available. This is happening because Connection Timeout is equal to Response Timeout, which is equal to <code>upperElectionTimeout</code>.</li>
<li>On Linux everything is fine because Connection Timeout less than Response Timeout</li>
</ul>
<p>By default, Raft implementation uses <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler">SocketsHttpHandler</a>. However, the handler can be overridden using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.ihttpmessagehandlerfactory">IHttpMessageHandlerFactory</a>. You can implement this interface manually and register that implementation as a singleton. .NEXT tries to use this interface if it is registered as a factory of custom <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpmessagehandler">HttpMessageHandler</a>. The following example demonstrates how to implement this interface and create platform-independent version of message invoker:</p>
<pre><code class="lang-csharp">using System;
using System.Net.Http;

internal sealed class RaftClientHandlerFactory : IHttpMessageHandlerFactory
{
	public HttpMessageHandler CreateHandler(string name) =&gt; new SocketsHttpHandler { ConnectTimeout = TimeSpan.FromMilliseconds(100) };
}
</code></pre>
<p>In practice, <code>ConnectTimeout</code> should be equal to or less than <code>lowerElectionTimeout</code> configuration property. Note that <code>name</code> parameter is equal to the <code>clientHandlerName</code> configuration property when handler creation is requested by Raft implementation.</p>
<h3 id="redirection-to-leader">Redirection to Leader</h3>
<p>Client interaction requires automatic detection of a leader node. Cluster Development Suite provides a way to automatically redirect requests to the leader node if it was originally received by a follower node. The redirection is organized with help of <em>307 Temporary Redirect</em> status code. Every follower node knows the actual address of the leader node. If cluster or its partition doesn't have leader then node returns <em>503 Service Unavailable</em>.</p>
<p>Automatic redirection can be configured using <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.Http.ConfigurationExtensions.html">RedirectToLeader</a> extension method.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft.Http;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class Startup
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public void ConfigureServices(IServiceCollection services)
    {
    }
}
</code></pre>
<p>This redirection can be transparent to actual client if you use reverse proxy server such as NGINX. Reverse proxy can automatically handle the redirection without returning control to the client.</p>
<p>It is possible to change default behavior of redirection where <em>301 Moved Permanently</em> status code is used. You can pass custom implementation into the optional parameter of <code>RedirectToLeader</code> method.</p>
<p>The following example demonstrates how to return <em>404 Not Found</em> and location of Leader node as its body.</p>
<pre><code class="lang-csharp">private static Task CustomRedirection(HttpResponse response, Uri leaderUri)
{
    response.StatusCode = StatusCodes.Status404NotFound;
    return response.WriteAsync(leaderUri.AbsoluteUri);
}

public void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
        .RedirectToLeader(&quot;/endpoint1&quot;, redirection: CustomRedirection);
}
</code></pre>
<p>The customized redirection should be as fast as possible and don't block the caller.</p>
<h3 id="port-mapping">Port mapping</h3>
<p>Redirection mechanism trying to construct valid URI of the leader node based on its actual IP address. Identification of the address is not a problem unlike port number. The infrastructure cannot use the port if its <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webhost">WebHost</a> because of Hosted Mode or the port from the incoming <code>Host</code> header because it can be rewritten by reverse proxy. The only way is to use the inbound port of the TCP listener responsible for handling all incoming HTTP requests. It is valid for the non-containerized environment. Inside of the container the ASP.NET Core application port is mapped to the externally visible port which not always the same. In this case you can specify port for redirections explicitly as follows:</p>
<pre><code class="lang-csharp">public void Configure(IApplicationBuilder app)
{
    app.UseConsensusProtocolHandler()
      .RedirectToLeader(&quot;/endpoint1&quot;, applicationPortHint: 3265);
}
</code></pre>
<h3 id="messaging">Messaging</h3>
<p>Cluster Programming Suite supports messaging beween nodes through HTTP out-of-the-box. However, the infrastructure don't know how to handle custom messages. Therefore, if you want to utilize this functionality then you need to implement <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IInputChannel.html">IInputChannel</a> interface.</p>
<p>Messaging inside of cluster supports redirection to the leader as well as for external client. But this mechanism implemented differently and exposed as <code>IInputChannel</code> interface via <code>LeaderRouter</code> property of <a class="xref" href="../../api/DotNext.Net.Cluster.Messaging.IMessageBus.html">IMessageBus</a> interface.</p>
<h3 id="replication">Replication</h3>
<p>Raft algorithm requires additional persistent state in order to basic audit trail. This state is represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface. By default, it is implemented as <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.ConsensusOnlyState.html">ConsensusOnlyState</a> which is suitable only for applications that doesn't have replicated state. If your application has it, then use <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.MemoryBasedStateMachine.html">MemoryBasedStateMachine</a> class or implement the interface from scratch. The implementation can be injected explicitly via <code>AuditTrail</code> property of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftCluster.html">IRaftCluster</a> interface or implicitly via Dependency Injection. The explicit registration should be done inside of the user-defined implementation of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IClusterMemberLifetime.html">IClusterMemberLifetime</a> interface registered as a singleton service in ASP.NET Core application. The implicit injection requires registration of a singleton service implementing <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IPersistentState.html">IPersistentState</a> interface. <code>UsePersistenceEngine</code> extension method of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftClusterConfiguration.html">RaftClusterConfiguration</a> class can be used for that purpose.</p>
<p>Information about reliable persistent state that uses non-volatile storage is located in the separated <a href="wal.html">article</a>. However, its usage turns your microservice into stateful service because its state must be persisted on a disk. Consider this fact if you are using containerization technologies such as Docker or LXC.</p>
<h3 id="metrics">Metrics</h3>
<p>It is possible to measure runtime metrics of Raft node internals using <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.Http.HttpMetricsCollector.html">HttpMetricsCollector</a> class. The reporting mechanism is agnostic to the underlying metrics delivery library such as <a href="https://github.com/AppMetrics/AppMetrics">AppMetrics</a>.</p>
<p>The class contains methods that are called automatically. You can override them and implement necessary reporting logic. By default, these methods report metrics to .NET Performance Counters.</p>
<p>The metrics collector should be registered as singleton service using Dependency Injection. However, the type of the service used for registration should of <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.MetricsCollector.html">MetricsCollector</a> type.</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;
using DotNext.Net.Cluster.Consensus.Raft.Http;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

sealed class MyCollector : HttpMetricsCollector
{
	public override void ReportResponseTime(TimeSpan value)
    {
		//report response time of the cluster member
    } 

	public override void ReportBroadcastTime(TimeSpan value)
    {
		//report broadcast time measured during sending the request to all cluster members
    }
}

sealed class Startup 
{
    private readonly IConfiguration configuration;

    public Startup(IConfiguration configuration) =&gt; this.configuration = configuration;

    public void Configure(IApplicationBuilder app)
    {
        app.UseConsensusProtocolHandler()
			.RedirectToLeader(&quot;/endpoint1&quot;)
			.RedirectToLeader(&quot;/endpoint2&quot;);
    }

    public void ConfigureServices(IServiceCollection services)
    {
		services.AddSingleton&lt;MetricsCollector, MyCollector&gt;();
    }
}
</code></pre>
<p>It is possible to derive directly from <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.MetricsCollector.html">MetricsCollector</a> if you don't need to receive metrics related to HTTP-specific implementation of Raft algorithm.</p>
<h2 id="tcp-transport">TCP Transport</h2>
<p>TCP transport used as bottom layer for specialized application protocol aimed to efficient transmission of Raft messages. This transport can be configured using <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster.TcpConfiguration.html">TcpConfiguration</a> class:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;

RaftCluster.NodeConfiguration config = new RaftCluster.TcpConfiguration(new IPEndPoint(IPAddress.Loopback));
using var cluster = new RaftCluster(config);
await cluster.StartAsync(CancellationToken.None); //starts hosting of the local node
//the code for working with cluster instance
await cluster.StopAsync(CancellationToken.None);    //stops hosting of the local node
</code></pre>
<p>Constructor expecting address and port used for hosting of the local node.</p>
<p>The following table describes configuration properties applicable to TCP transport:</p>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServerBacklog</td>
<td>No</td>
<td>Equal to the number of cluster members</td>
<td>The number of active incoming connections allowed by the local node</td>
</tr>
<tr>
<td>LingerOption</td>
<td>No</td>
<td>Not enabled</td>
<td>The configuration that specifies whether a TCP socket will delay its closing in an attempt to send all pending data</td>
</tr>
<tr>
<td>GracefulShutdownTimeout</td>
<td>No</td>
<td>The same as <em>LowerElectionTimeout</em></td>
<td>The timeout of graceful shutdown of active incoming connections</td>
</tr>
<tr>
<td>TransmissionBlockSize</td>
<td>No</td>
<td>65535</td>
<td>The size, in bytes, of internal memory block used for sending packets. If your network has high packet loss then you can decrease this value to avoid retransmission of large blocks.</td>
</tr>
<tr>
<td>ConnectTimeout</td>
<td>No</td>
<td>The same as <em>LowerElectionTimeout / 2</em></td>
<td>TCP connection timeout. Must be less than or equal to <em>LowerElectionTimeout</em></td>
</tr>
<tr>
<td>SslOptions</td>
<td>No</td>
<td><em>N/A</em></td>
<td>Allows to enable and configure transport-level encryption using SSL and X.509 certificates</td>
</tr>
</tbody>
</table>
<p>TCP transport is WAN friendly and support transport-level encryption. However, the underlying application-level protocol is binary and can be a problem for corporate firewalls.</p>
<h2 id="udp-transport">UDP Transport</h2>
<p>UDP transport used as bottom layer for specialized application protocol aimed to efficient transmission of Raft messages. This transport doesn't use persistent connection in contrast to TCP. As a result, it has no TCP overhead related to congestion and flow control of messages. These capabilities are implemented by application protocol itself. However, retransmission of lost packets is not implemented. The transport uses pessimistic approach and interprets lost packets as connection timeout. This is reasonable approach because the leader node examines other cluster members periodically and the next attempt may be successful. Some Raft messages such as <em>Vote</em> and <em>Heartbeat</em> with empty set of log entries (or if log entries are small enough) for replication can be easily placed to single datagram without fragmentation.</p>
<p>The transport has very low overhead which is equal to ~20 bytes per datagram. Therefore, most Raft messages can be placed to single datagram without streaming per request.</p>
<p>UDP transport cannot detect path <a href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">MTU</a> automatically and, by default, it uses minimal safe size of the datagram to avoid fragmentation. If need automatic path MTU discovery then use <a href="../core/mtu.html">MTU discovery</a> mechanism from .NEXT. After that, you can specify datagram size using configuration properties.</p>
<p>This transport can be configured using <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster.UdpConfiguration.html">UdpConfiguration</a> class:</p>
<table>
<thead>
<tr>
<th>Configuration parameter</th>
<th>Required</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServerBacklog</td>
<td>No</td>
<td>Equal to the number of cluster members</td>
<td>The number of incoming requests that can be handled simultaneously</td>
</tr>
<tr>
<td>ClientBacklog</td>
<td>No</td>
<td>Equal to the number of logical processor on the host machine</td>
<td>The number of outbound requests that can be initiated by the local node</td>
</tr>
<tr>
<td>DontFragment</td>
<td>No</td>
<td>true</td>
<td>Indicates that datagram cannot be fragmented by the underlying network layer such as IP (DF flag)</td>
</tr>
<tr>
<td>DatagramSize</td>
<td>No</td>
<td>300 bytes</td>
<td>Represents UDP datagram size. For maximum performance, this property must be set to the maximum allowed transmission unit size by your network</td>
</tr>
<tr>
<td>LocalEndPoint</td>
<td>No</td>
<td>0.0.0.0 with random port</td>
<td>Used for receiving responses from other cluster nodes</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates configuration of UDP transport:</p>
<pre><code class="lang-csharp">using DotNext.Net.Cluster.Consensus.Raft;

RaftCluster.NodeConfiguration config = new RaftCluster.UdpConfiguration(new IPEndPoint(IPAddress.Loopback));
using var cluster = new RaftCluster(config);
await cluster.StartAsync(CancellationToken.None); //starts hosting of the local node
//the code for working with cluster instance
await cluster.StopAsync(CancellationToken.None);    //stops hosting of the local node
</code></pre>
<p>If you are using Docker/LXC/Windows container for the clustered microservices based on UDP transport then you can leave <code>LocalEndPoint</code> untouched. Otherwise, it's recommended to use the address of the appropriate local network interface.</p>
<p>UDP transport is WAN unfriendly. It should not be used in unreliable networks. However, it's much faster than TCP transport. It is recommended to use this protocol in the following situations:</p>
<ul>
<li>Cluster nodes are hosted in the same rack</li>
<li>Cluster nodes are hosted in the different racks but located in the same datacenter and racks connected by high-speed physical interface such as FibreChannel.</li>
<li>Cluster nodes are in Docker/LXC/Windows containers running on the same physical host</li>
</ul>
<h1 id="example">Example</h1>
<p>There is Raft playground represented by RaftNode application. You can find this app <a href="https://github.com/dotnet/dotNext/tree/master/src/examples/RaftNode">here</a>. This playground allows to test Raft consensus protocol in real world using one of the supported transports: <code>http</code>, <code>tcp</code>, <code>tcp+ssl</code>, <code>udp</code>.</p>
<p>Each instance of launched application represents cluster node. All nodes can be started using the following script:</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- http 3262
dotnet run -- http 3263
dotnet run -- http 3264
</code></pre>
<p>Every instance should be launched in separated Terminal session. After that, you will see diagnostics messages in <code>stdout</code> about election process. Press <em>Ctrl+C</em> in the window related to the leader node and ensure that new leader will be elected.</p>
<p>Optionally, you can test replication powered by persistent WAL. To do that, you need to specify the name of folder which is used to store Write Ahead Log files</p>
<pre><code class="lang-bash">cd &lt;dotnext&gt;/src/examples/RaftNode
dotnet run -- http 3262 node1
dotnet run -- http 3263 node2
dotnet run -- http 3264 node3
</code></pre>
<p>Now you can see replication messages in each Terminal window. The replicated state stored in the <code>node1</code>, <code>node2</code> and <code>node3</code> folders. You can restart one of the nodes and make sure that its state is recovered correctly.</p>
<h1 id="development-and-debugging">Development and Debugging</h1>
<p>It may be hard to reproduce the real cluster on developer's machine. You may want to run your node in <em>Debug</em> mode and ensure that the node you're running is a leader node. To do that, you need to start the node in <em>Cold Start</em> mode.</p>
<h1 id="performance">Performance</h1>
<p>The wire format is highly optimized for transferring log entries during the replication process over the wire. The most performance optimizations should be performed when configuring persistent Write-Ahead Log.</p>
<p><a href="(xref:DotNext.Net.Cluster.Consensus.Raft.MemoryBasedStateMachine)">MemoryBasedStateMachine</a> supports several log compaction modes. Some of them allow compaction in parallel with appending of new log entries. Read <a href="wal.html">this article</a> for more information about the available modes. <em>Background</em> compaction provides precise control over the compaction. There are few ways to control it:</p>
<ol>
<li>If you're using <code>UsePersistenceEngine</code> extension method for registering your engine based on <code>MemoryBasedStateMachine</code> then .NEXT infrastructure automatically detects the configured compaction mode. If it is <em>Background</em> then it will register <em>compaction worker</em> as a background service in ASP.NET Core. This worker provides <em>incremental background compaction</em>. You can override this behavior by implementing <a class="xref" href="../../api/DotNext.IO.Log.ILogCompactionSupport.html">ILogCompactionSupport</a> in your persistence engine.</li>
<li>If you're registering persistence engine in DI container manually, you need to implement background compaction worker manually using <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.backgroundservice.startasync">BackgroundService</a> class and call <code>ForceCompactionAsync</code> method in the overridden <code>ExecuteAsync</code> method.</li>
</ol>
<p><em>Incremental background compaction</em> is the default strategy when <em>Background</em> compaction enabled. The worker just waits for the commit and checks whether <code>MemoryBasedStateMachine.CompactionCount</code> property is greater than zero. If so, it calls <code>ForceCompactionAsync</code> with the compaction factor which is equal to 1. It provides minimal compaction of the log. As a result, the contention between the compaction worker and readers is minimal or close to zero.</p>
<h1 id="guide-how-to-implement-database">Guide: How To Implement Database</h1>
<p>This section contains recommendations about implementation of your own database or distributed service based on .NEXT Cluster programming model. It can be K/V database, distributed UUID generator, distributed lock or anything else.</p>
<p>For memory-based state machine:</p>
<ol>
<li>Derive from <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.MemoryBasedStateMachine.html">MemoryBasedStateMachine</a> class to implement core logic related to manipulation with state machine
<ol>
<li>Override <code>ApplyAsync</code> method which contains interpretation of commands contained in log entries</li>
<li>Override <code>CreateSnapshotBuilder</code> method which is responsible for log compaction</li>
<li>Expose high-level data operations declared in the derived class in the form of interface. Let's assume that its name is <code>IDataEngine</code></li>
</ol>
</li>
<li>Declare class that is responsible for communication with leader node using custom messages
<ol>
<li>This class aggregates reference to <code>IDataEngine</code></li>
<li>This class encapsulates logic for messaging with leader node</li>
<li>This class acting as controller for API exposed to external clients</li>
<li>Use <code>IRaftCluster.ApplyReadBarrierAsync</code> to ensure that the node is fully synchronized with the leader node</li>
<li>Use <code>IRaftCluster.ReplicateAsync</code> for write operations</li>
</ol>
</li>
<li>Expose data manipulation methods from class described above to clients using selected network transport</li>
<li>Implement duplicates elimination logic for write requests from clients</li>
<li>Call <code>ReplayAsync</code> method which is inherited from <code>MemoryBasedStateMachine</code> class at application startup. This step is not need if you're using Raft implementation for ASP.NET Core.</li>
</ol>
<p><code>ForceReplicationAsync</code> method doesn't provide strong guarantees that the log entry at the specified index will be replicated and committed on return. A typical code for processing a new log entry from the client might be look like this:</p>
<pre><code class="lang-csharp">IRaftCluster cluster = ...;
var term = cluster.Term;
await cluster.ReplicateAsync(new MyLogEntry(term), Timeout.InfiniteTimeSpan, token);
</code></pre>
<p>The same pattern is applicable to <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.DiskBasedStateMachine.html">disk-based state machine</a> except snapshotting except snapshotting.</p>
<p>Designing binary format for custom log entries and interpreter for them may be hard. Examine <a href="wal.html">this</a> article to learn how to use Interpreter Framework shipped with the library.</p>
<h1 id="guide-custom-transport">Guide: Custom Transport</h1>
<p>Transport-agnostic implementation of Raft is represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.RaftCluster-1.html">RaftCluster&lt;TMember&gt;</a> class. It contains core consensus and replication logic but it's not aware about network-specific details. You can use this class as foundation for your own Raft implementation for particular network protocol. All you need is to implementation protocol-specific communication logic.  This chapter will guide you through all necessary steps.</p>
<h2 id="existing-implementations">Existing Implementations</h2>
<p>.NEXT library ships multiple network transports:</p>
<ul>
<li><a href="https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.AspNetCore.Cluster/Net/Cluster/Consensus/Raft/Http/RaftHttpCluster.cs">RaftHttpCluster</a> as a part of <code>DotNext.AspNetCore.Cluster</code> library offers HTTP 1.1/HTTP 2/HTTP 3 implementations adopted for ASP.NET Core framework</li>
<li><a href="https://github.com/dotnet/dotNext/tree/develop/src/cluster/DotNext.Net.Cluster/Net/Cluster/Consensus/Raft/TransportServices">TransportServices</a> as a part of <code>DotNext.Net.Cluster</code> library contains reusable network transport layer for UDP and TCP transport shipped as a part of this library</li>
</ul>
<p>All these implementations can be used as examples of transport for Raft messages.</p>
<h2 id="architecture">Architecture</h2>
<p><code>RaftCluster</code> contains implementation of consensus and replication logic so your focus is network-specific programming. First of all, you need to derive from this class. There are two main extensibility points when network-specific programing needed:</p>
<ul>
<li><code>TMember</code> generic parameter which should be replaced with actual type argument by the derived class. Actual type argument should be a class implementing <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftClusterMember.html">IRaftClusterMember</a> interface and other generic constraints. This part of implementation contains code necessary for sending Raft-specific messages over the wire.</li>
<li>Body of derived class itself. This part of implementation contains code necessary for receiving Raft-specific messages over the wire.</li>
</ul>
<p>From architecture point of view, these two parts are separated. However, the actual implementation may require a bridge between them.</p>
<h2 id="cluster-member">Cluster Member</h2>
<p><a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftClusterMember.html">IRaftClusterMember</a> declares the methods that are equivalent to Raft-specific message types.</p>
<p><code>NextIndex</code> property should return a location in memory to the index of the next log entry to be replicated for the current member. It doesn't contain any logic.</p>
<pre><code class="lang-csharp">using DotNext;
using DotNext.Net.Cluster.Consensus.Raft;

sealed class ClusterMember : Disposable, IRaftClusterMember
{
    private long nextIndex;

    ref long IRaftClusterMember.NextIndex =&gt; ref nextIndex;
}
</code></pre>
<p><code>VoteAsync</code>, <code>PreVoteAsync</code>, <code>AppendEntriesAsync</code>, <code>InstallSnapshotAsync</code> are methods for sending Raft-specific messages over the wire. They are called automatically by core logic located in <code>RaftCluster</code> class. Implementation of these methods should throw <a class="xref" href="../../api/DotNext.Net.Cluster.MemberUnavailableException.html">MemberUnavailableException</a> if any network-related problem occurred.</p>
<p>The last two methods responsible for serializing log entries to the underlying network connection. <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftLogEntry.html">IRaftLogEntry</a> is inherited from <a class="xref" href="../../api/DotNext.IO.IDataTransferObject.html">IDataTransferObject</a> which represents abstraction for Data Transfer Object. DTO is an object that can be serialized to or deserialized from binary form. However, serialization/deserialization process and binary layout are fully controlled by DTO itself in contrast to classic .NET serialization. You need to wrap underlying network stream to <a class="xref" href="../../api/DotNext.IO.IAsyncBinaryWriter.html">IAsyncBinaryWriter</a> and pass it to <code>IDataTransferObject.WriteAsync</code> method for each log entry. <code>IAsyncBinaryWriter</code> interface has built-in static factory methods for wrapping <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">streams</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter">pipes</a>. Note that <code>IDataTransferObject.Length</code> may return <strong>null</strong> and you will not be able to identify log record size (in bytes) during serialization. This behavior depends on underlying implementation of Write-Ahead Log. You can examine value of <code>IAuditTrail.IsLogEntryLengthAlwaysPresented</code> property to apply necessary optimizations to the transmission process:</p>
<ul>
<li>If it's <strong>true</strong> then all log entries retrieved from such log has known size in bytes and <code>IDataTransferObject.Length</code> is not <strong>null</strong>.</li>
<li>If it's <strong>false</strong> then some or all log entries retrieved from such log has unknown size in bytes and <code>IDataTransferObject.Length</code> may be <strong>null</strong>. Thus, you need to provide special logic which allows to write binary data of undefined size to the underlying connection.</li>
</ul>
<p>The default implementation for ASP.NET Core covers both cases. It uses multipart content type where log records separated by the special boundary from each other if <code>IAuditTrail.IsLogEntryLengthAlwaysPresented</code> returns <strong>false</strong>. Otherwise, more optimized transfer over the wire is applied. In this case, the overhead is comparable to the raw TCP connection.</p>
<p><code>ResignAsync</code> method sends the message to the leader node and receiver should downgrade itself to the follower state. This is service message type not related to Raft but can be useful to force leader election.</p>
<p>You can use <a href="https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.AspNetCore.Cluster/Net/Cluster/Consensus/Raft/Http/RaftClusterMember.cs">this</a> code as an example of HTTP-specific implementation.</p>
<h2 id="derivation-from-raftcluster">Derivation from RaftCluster</h2>
<p><code>RaftCluster</code> class contains all necessary methods for handling deserialized Raft messages:</p>
<ul>
<li><code>AppendEntriesAsync</code> method allows to handle <em>AppendEntries</em> Raft message type that was sent by another node</li>
<li><code>ResignAsync</code> method allows to handle leadership revocation procedure</li>
<li><code>InstallSnapshotAsync</code> method allows to handle <em>InstallSnapshot</em> Raft message type that was sent by another node</li>
<li><code>VoteAsync</code> method allows to handle <em>Vote</em> Raft message type that was sent by another node</li>
<li><code>PreVoteAsync</code> method allows to handle <em>PreVote</em> message introduced as extension to original Raft model to avoid inflation of <em>Term</em> value</li>
</ul>
<p>The underlying code responsible for listening network requests must restore Raft messages from transport-specific representation and call the necessary handler for particular message type.</p>
<p>It is recommended to use <strong>partial class</strong> feature of C# language to separate different parts of the derived class. The recommended layout is:</p>
<ul>
<li>Main part with <code>StartAsync</code> and <code>StopAsync</code> methods containing initialization logic, configuration and other infrastructure-related aspects. The example is <a href="https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.AspNetCore.Cluster/Net/Cluster/Consensus/Raft/Http/RaftHttpCluster.cs">here</a></li>
<li>Raft-related messaging. The example is <a href="https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.AspNetCore.Cluster/Net/Cluster/Consensus/Raft/Http/RaftHttpCluster.Messaging.cs">here</a></li>
<li>General-purpose messaging (if you need it)</li>
</ul>
<p><code>AppendEntriesAsync</code> and <code>InstallSnapshotAsync</code> expecting access to the log entries deserialized from the underlying transport. This is where <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IRaftLogEntry.html">IRaftLogEntry</a> interface comes into play. Transport-specific implementation of <code>IRaftLogEntry</code> should be present on the receiver side. Everything you need is just wrap section of underlying stream into instance of <a class="xref" href="../../api/DotNext.IO.IAsyncBinaryReader.html">IAsyncBinaryReader</a> and pass the reader to <a class="xref" href="../../api/DotNext.IO.IDataTransferObject.ITransformation-1.html">Transformation</a> that comes through the parameter of <code>TransformAsync</code> method. The example is <a href="https://github.com/dotnet/dotNext/blob/master/src/cluster/DotNext.AspNetCore.Cluster/Net/Cluster/Consensus/Raft/Http/AppendEntriesMessage.cs">here</a>. <code>IAsyncBinaryReader</code> has static factory methods for wrapping <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">streams</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader">pipes</a>.</p>
<p>Another important extensibility points are <code>StartAsync</code> and <code>StopAsync</code> virtual methods. They are responsible for lifecycle management of <code>RaftCluster</code> instance. You can override them for the following reasons:</p>
<ul>
<li>Opening and closing sockets</li>
<li>Sending announcement to other nodes</li>
<li>Detection of local cluster member</li>
<li>Initialization of a list of cluster members</li>
<li>Enforcement of configuration</li>
</ul>
<h2 id="inputoutput">Input/Output</h2>
<p>Low-level code related to network communication requires a choice of I/O core framework. There are two standard approaches:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">Streams</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipe">Pipes</a></li>
</ul>
<p>Pipe is more preferred way because of its asynchronous nature and shared memory buffer between consumer and producer. As a result, it gives you a small memory footprint during intense I/O operations. Read <a href="https://docs.microsoft.com/en-us/dotnet/standard/io/pipelines">this</a> article to learn more.</p>
<p>.NEXT has broad support of I/O pipelines:</p>
<ul>
<li><code>IAsyncBinaryReader.Create</code> static factory method can wrap <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader">PipeReader</a> to enable high-level decoding operations</li>
<li><code>IAsyncBinaryWriter.Create</code> static factory method can wrap <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter">PipeWriter</a> to enable high-level encoding operations</li>
<li>Various <a href="../io/index.html">I/O enhancements</a> aimed to simplify programming using pipes</li>
</ul>
<h2 id="network-programming">Network programming</h2>
<p>The most important configuration of Raft cluster member is election timeout. Your transport-specific implementation should align socket timeouts correctly with it. For instance, connection timeout should not be greater than lower election timeout. Otherwise, you will have unstable cluster with frequent re-elections.</p>
<p>Another important aspect is a deduplication of Raft messages which is normal situation for TCP protocol. <em>Vote</em>, <em>PreVote</em> and <em>InstallSnapshot</em> are idempotent messages and can be handled twice by receiver. However, <em>AppendEntries</em> is not.</p>
<h2 id="hosting-model">Hosting Model</h2>
<p>The shape of your API for transport-specific Raft implementation depends on how the potential users will host it. There are few possible situations:</p>
<ul>
<li>Using Dependency Injection container:
<ul>
<li>Generic application host from <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting">Microsoft.Extensions.Hosting</a></li>
<li>Web host from ASP.NET Core</li>
<li>Third-party Dependency Injection container</li>
</ul>
</li>
<li>Standalone application without DI container</li>
</ul>
<p>In case of DI container from Microsoft you need to implement <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostedservice">IHostedService</a> in your derived class. The signatures of <code>StartAsync</code> and <code>StopAsync</code> methods from <code>RaftCluster</code> class are fully compatible with this interface so you don't need implement interface methods manually. As a result, you will have automatic lifecycle management and configuration infrastructure at low cost. The instance of your class which is derived from <code>RaftCluster</code> should be registered as singleton service. All its interfaces should be registered separately.</p>
<p>Different DI container requires correct adoption of your implementation.</p>
<p>If support of DI container is not a concern for you then appropriate configuration API and lifecycle management should be provided to the potential users.</p>
<p>The configuration of a cluster member is represented by <a class="xref" href="../../api/DotNext.Net.Cluster.Consensus.Raft.IClusterMemberConfiguration.html">IClusterMemberConfiguration</a> interface. Your configuration model should be based on this interface because it should be passed to the constructor of <code>RaftCluster</code> class. Concrete implementation of the configuration model depends on the hosting model.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/cluster/raft.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>
          
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In This Article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
              Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
              
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
