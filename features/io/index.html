<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>I/O Enhancements | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="I/O Enhancements | .NEXT ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="io-enhancements">I/O Enhancements</h1>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader">BinaryReader</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter">BinaryWriter</a> are aimed to high-level parsing or writing of stream content. These classes have several drawbacks:</p>
<ul>
<li>They don't provide asynchronous alternatives, especially for string</li>
<li>They should be allocated on the heap</li>
<li>They use internal buffer that is not accessible publicly</li>
</ul>
<p>The situation is worse when you need to have parse and write into the stream in the same time. In this case you need both <code>BinaryReader</code> and <code>BinaryWriter</code> with their own allocated buffers. So you have fourfold price: instance of writer and its internal buffer in the form of the array and instance of reader with its internal buffer. It is more complicated if your stream contains strings of different encodings.</p>
<p><a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.IO/StreamExtensions">StreamExtension</a> class contains extension methods for high-level parsing of stream content as well as typed writers with the following benefits:</p>
<ul>
<li>You can share the same buffer between reader and writer methods</li>
<li>You can manage how the buffer should be allocated: from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1">array pool</a> or using <strong>new</strong> keyword</li>
<li>You can use different encodings to encode or decode strings in the same stream</li>
<li>Endianness of value types under your control</li>
</ul>
<p>The following example demonstrates how to use these methods:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using DotNext.IO;
using System.Buffers.Binary;
using System.IO;

//read
using var fs = new FileStream(&quot;content.bin&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);
var str = await fs.ReadStringAsync(LengthFormat.Plain, Encoding.UTF8);
</code></pre>
<p>String encoding and decoding methods support various length encoding styles using <a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.IO/LengthFormat">LengthFormat</a> enum type. As a result, you can prefix string with its length automatically.</p>
<h1 id="segmenting-streams">Segmenting Streams</h1>
<p>In some cases you may need to hide the entire stream from the callee for the reading operation. This can be necessary to protect underlying stream from accidental seeking. <a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.IO/StreamSegment">StreamSegment</a> do the same for streams as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.arraysegment-1">ArraySegment</a> for arrays.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Stream segment is read-only stream that cannot be used for writes</p>
</div>
<p>The segment can be reused for multiple consumers because its position and length can be adjusted for the same instance.</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System.IO;

var fs = new FileStream(&quot;content.bin&quot;, FileMode.Open, FileAccess.Read, FileShare.Read);
using var segment = new StreamSegment(fs);
foreach(Action&lt;Stream&gt; consumer in consumers)
{
    segment.Adjust(10L, 1024L); //fs is limited to the segment limited by the offset of 10 from the beginning of the stream and length of 1024 bytes
    consumer(segment);
}
</code></pre>
<h1 id="pipelines">Pipelines</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines">System.IO.Pipelines</a> knowns as high-performance alternative to .NET streams. However, it doesn't have built-in helpers for encoding and decoding strongly-typed data such as blittable value types and strings that are provided by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.binaryreader">BinaryReader</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.binarywriter">BinaryWriter</a> classes. .NEXT I/O library provides API surface in the form of extensions methods that cover all these needs and turns I/O pipelines into first-class citizen in the world of high-level I/O operations. With these methods you can easily swith from streams to pipes without increasing complexity of code.</p>
<p>The following example demonstrates string encoding and decoding using I/O pipelines:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using DotNext.IO.Pipelines;
using System.IO.Pipelines;

const string value = &quot;Hello, world!&quot;;
var pipe = new Pipe();
await pipe.Writer.WriteStringAsync(value.AsMemory(), Encoding.UTF8, 0, LengthFormat.Plain);
var result = await pipe.Reader.ReadStringAsync(LengthFormat.Plain, Encoding.UTF8);
</code></pre>
<p>In advance to strings, the library supports decoding and encoding values of arbitrary blittable value types.</p>
<pre><code class="lang-csharp">using DotNext.IO.Pipelines;
using System.IO.Pipelines;

var pipe = new Pipe();
await pipe.Writer.WriteAsync(Guid.NewGuid());
var result = await pipe.Reader.ReadAsync&lt;Guid&gt;();
</code></pre>
<p>Starting with version <em>2.6.0</em> there is <a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.Buffers/BufferWriter">BufferWriter</a> class with extension methods for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;byte&gt;</a> interface allowing to encode strings and primitives synchronously. Now it's possible to control flushing more granular:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using DotNext.IO.Pipelines;
using System.IO.Pipelines;
using System.Text;

var pipe = new Pipe();
pipe.Writer.Write(Guid.NewGuid());
pipe.Writer.WriteString(&quot;Hello, world!&quot;.AsSpan(), Encoding.UTF8, LengthFormat.Plain);
await pipe.Writer.FlushAsync();
</code></pre>
<h1 id="decoding-data-from-readonlysequence">Decoding Data from ReadOnlySequence</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1">ReadOnlySequence&lt;byte&gt;</a> is a convenient way to read from non-contiguous blocks of memory. However, this API is too low-level and doesn't provide high-level methods for parsing strings and primitives. <a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.IO/SequenceBinaryReader">SequenceBinaryReader</a> value type is a wrapper for the sequence of memory blocks that provides high-level decoding methods:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System;
using System.Buffers;
using System.Text;

ReadOnlySequence&lt;byte&gt; sequence = ...;
SequenceBinaryReader reader = IAsyncBinaryReader.Create(sequence);
int i = reader.ReadInt32(BitConverter.IsLittleEndian);
string str = reader.ReadString(LengthFormat.Plain, Encoding.UTF8);
</code></pre>
<h1 id="file-buffering-writer">File-Buffering Writer</h1>
<p><a class="xref" href="https://fuget.org/packages/DotNext.IO/3.2.0/lib/net5.0/DotNext.IO.dll/DotNext.IO/FileBufferingWriter">FileBufferingWriter</a> class can be used as a temporary buffer of bytes when length of the content is not known or dynamic. It's useful in the following situations:</p>
<ul>
<li>Synchronous serialization to stream and copying result to another stream asynchronously</li>
<li>Asynchronous serialization to stream and copying result to another stream synchronously</li>
<li>Synchronous serialization to stream and copying result to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipewriter">PipeWriter</a> asynchronously</li>
<li>Bufferized write to another stream when it's not available immediately</li>
<li>Bufferize input data and read afterwards</li>
<li>Dynamic buffer should be represented as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a></li>
</ul>
<p>In other words, this class has many similarities with <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webutilities.filebufferingwritestream">FileBufferingWriteStream</a>. However, <code>FileBufferingWriter</code> has a few advantages:</p>
<ul>
<li>It doesn't depend on ASP.NET Core</li>
<li>Ability to use custom <a class="xref" href="https://fuget.org/packages/DotNext/3.2.0/lib/net5.0/DotNext.dll/DotNext.Buffers/MemoryAllocator%601">MemoryAllocator&lt;T&gt;</a> for memory pooling</li>
<li>Selection between synchronous and asynchronous modes</li>
<li>Ability to read the file used as backing store after closing the writer</li>
<li>Can drain content to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;byte&gt;</a></li>
<li>Ability to read written content as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">Stream</a></li>
<li>Ability to represent written content as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;byte&gt;</a></li>
<li>Ability to represent written content as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1">ReadOnlySequence&lt;byte&gt;</a> if it's too large for representation in the form of <code>Memory&lt;byte&gt;</code> data type</li>
</ul>
<p>The last two features are very useful in situations when the size of memory is not known at the time of the call of write operations. If written content is in memory then returned <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a> just references it. Otherwise, <code>FileBufferingWriter</code> utilizes memory-mapped file feature and returned <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1">Memory&lt;T&gt;</a> represents mapped virtual memory. It's better than using pooled memory because of memory deterministic lifetime and GC pressure.</p>
<p>The following example demonstrates this feature:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System.Buffers;

using var writer = new FileBufferingWriter();
writer.Write(new byte[] {10, 20, 30});
using (IMemoryOwner&lt;byte&gt; manager = writer.GetWrittenContent())
{
    Memory&lt;byte&gt; memory = manager.Memory;
}
</code></pre>
<p>If written content is too large to represent it as contiguous block of memory then it can be returned as <code>ReadOnlySequence&lt;byte&gt;</code>. Under the hood, this representation uses memory-mapped file as well. However, in constrast to representation of the whole content as <code>Memory&lt;byte&gt;</code>, sequence provides access to the linked non-contiguous memory blocks. Each memory block represents only a segment from the whole file. As a result, virtual memory is allocated for mapped segment only. Switching between segments is transparent for the consumer:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System.Buffers;

using var writer = new FileBufferingWriter();
writer.Write(...);

// The segment size to be mapped to the memory is 1 MB
using (IReadOnlySequenceSource source = writer.GetWrittenContent(1024 * 1024))
{
    ReadOnlySequence&lt;byte&gt; memory = source.Sequence;
}
</code></pre>
<p>The last option is to use stream-based API to read the written content:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System.IO;

using var writer = new FileBufferingWriter();
writer.Write(...);

// read data from the stream
using (Stream reader = writer.GetWrittenContentAsStream())
{
}
</code></pre>
<p>By default, the writer uses temporary file as backing store if in-memory buffer limit has been reached. This file will be deleted automatically when <code>Dispose</code> called. However, there is a way to leave the file untouched and reuse its content later. To do that, you need to specify file name explicitly:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System;

const string pathToFile = &quot;/absolute/path/to/file&quot;;
var options = new FileBufferingWriter.Options
{
    FileName = pathToFile,
};

using var writer = new FileBufferingWriter(options);

if (writer.TryGetWrittenContent(out ReadOnlyMemory&lt;byte&gt; block, out string fileName))
{
    // All written content is in memory block, file was not used as the backing store.
    // Thus, fileName is null
}
else
{
    // All written content is in file.
    // Thus, fileName contains full path to the file with the content and the memory block is empty
}
</code></pre>
<h1 id="encodingdecoding-of-memory-block">Encoding/decoding of Memory Block</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span&lt;T&gt;</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.readonlyspan-1">ReadOnlySpan&lt;T&gt;</a> are powerful data types for working with contiguous memory blocks. Random access to memory elements is perfectly supported by their public methods. However, there a lot of cases when sequential access to memory elements required. For instance, the frame of network protocol passed over the wire can be represented as span. Parsing or writing the frame is sequential operation. To cover such use cases, .NEXT exposes simple but powerful types aimed to simplify sequential access to span contents:</p>
<ul>
<li><a class="xref" href="https://fuget.org/packages/DotNext/3.2.0/lib/net5.0/DotNext.dll/DotNext.Buffers/SpanReader%601">SpanReader&lt;T&gt;</a> provides sequential reading of elements from the memory</li>
<li><a class="xref" href="https://fuget.org/packages/DotNext/3.2.0/lib/net5.0/DotNext.dll/DotNext.Buffers/SpanWriter%601">SpanWriter&lt;T&gt;</a> provides sequential writing of elements to the memory</li>
</ul>
<p>The following example demonstrates how to encode and decode values to/from the stack-allocated memory:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using System;
using static System.Runtime.InteropServices.MemoryMarshal;

Span&lt;byte&gt; memory = stackalloc byte[32];

// encodes int32, int64 and Guid values to stack-allocated memory
var writer = new SpanWriter&lt;byte&gt;(memory);
WriteInt32LittleEndian(writer.Slide(sizeof(int)), 42);
WriteInt64LittleEndian(writer.Slide(sizeof(long)), 42L);
writer.Write&lt;Guid&gt;(Guid.NewGuid());

// decodes int32, int64 and Guid values from stack-allocated memory
var reader = new SpanReader&lt;byte&gt;(memory);
var i32 = ReadInt32LittleEndian(reader.Read(sizeof(int)));
var i64 = ReadInt64LittleEndian(reader.Read(sizeof(long)));
var g = reader.Read&lt;Guid&gt;();
</code></pre>
<h1 id="text-reader-for-readonlysequence">Text Reader for ReadOnlySequence</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1">ReadOnlySequence&lt;char&gt;</a> can be wrapped as an instance of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.textreader">TextReader</a> class to read strings and characters in more convenient way. To do that, you need to call <code>AsTextReader</code> extension method:</p>
<pre><code class="lang-csharp">using DotNext.IO;
using System.Buffers;
using System.IO;

ReadOnlySequence&lt;char&gt; sequence = ...;
using TextReader reader = sequence.AsTextReader();
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/sakno/dotNext/blob/gh-pages/docs/features/io/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
                <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
              </div>
          
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
