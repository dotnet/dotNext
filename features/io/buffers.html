<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Dynamic Buffers | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Dynamic Buffers | .NEXT ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="dynamic-buffers">Dynamic Buffers</h1>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraybufferwriter-1">ArrayBufferWriter&lt;T&gt;</a> represents default implementation of dynamically-sized, heap-based and array-backed buffer. Unfortunately, it's not flexible enough in the following aspects:</p>
<ul>
<li>Not possible to use array or memory pooling mechanism. As a result, umnanaged memory cannot be used for such writer.</li>
<li>Not compatible with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.arraysegment-1">ArraySegment&lt;T&gt;</a></li>
<li>No easy way to obtain stream over written memory</li>
<li>Allocation on the heap</li>
</ul>
<p>With .NEXT, you have this flexibility.</p>
<h1 id="poolingbufferwriter">PoolingBufferWriter</h1>
<p><a class="xref" href="../../api/DotNext.Buffers.PoolingBufferWriter-1.html">PoolingBufferWriter&lt;T&gt;</a> is similar to <code>ArrayBufferWriter</code> but accepts <a class="xref" href="../../api/DotNext.Buffers.MemoryAllocator-1.html">memory allocator</a> that is used for allocation of internal buffers. Thus, you can use any pooling mechanism from .NET: memory or array pool. If writer detects that capacity exceeded then it rents a new internal buffer and copies written content from previous one.</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

using var writer = new PoolingBufferWriter&lt;byte&gt;(ArrayPool&lt;byte&gt;.Shared.ToAllocator());
Span&lt;byte&gt; span = writer.GetSpan(1024);
new byte[512].AsSpan().CopyTo(span);
span.Advance(512);
var result = writer.WrittenMemory;  //length is 512
</code></pre>
<p>In contrast to <code>ArrayBufferWriter</code>, you must not use written memory if <code>Dispose</code> is called. When <code>Dispose</code> method is called, the internal buffer returns to the pool.</p>
<h1 id="poolingarraybufferwriter">PoolingArrayBufferWriter</h1>
<p><a class="xref" href="../../api/DotNext.Buffers.PoolingArrayBufferWriter-1.html">PoolingArrayBufferWriter&lt;T&gt;</a> class exposes the similar functionality to <code>PoolingArrayBufferWriter</code> class but specialized for working with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1">ArrayPool&lt;T&gt;</a>. As a result, you can make writes or obtain written memory using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.arraysegment-1">ArraySegment&lt;T&gt;</a>.</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using DotNext.IO;
using System;

using var writer = new PoolingArrayBufferWriter&lt;byte&gt;(ArrayPool&lt;byte&gt;.Shared);
ArraySegment&lt;byte&gt; array = writer.GetArray(1024);
array[0] = 42;
array[1] = 43;
span.Advance(2);
ArraySegment&lt;byte&gt; result = writer.WrittenArray;
</code></pre>
<p>Additionally, it implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1">IList&lt;T&gt;</a> interface so you can use it as fully-functional list which rents the memory instead of allocation on the heap.</p>
<h1 id="sparse-buffer">Sparse Buffer</h1>
<p><a class="xref" href="../../api/DotNext.Buffers.SparseBufferWriter-1.html">SparseBufferWriter&lt;T&gt;</a> represents a writer for the buffer represented by a set of non-contiguous memory blocks. Its main advantage over previously described buffer types is a monotonic growth without reallocations. If the buffer has not enough space to place a new portion of data then it just allocates another contiguous buffer from the pool and attaches it to the end of the chain of buffers. Thus, the buffer growth has deterministic performance.</p>
<p>Additionally, sparse buffer allows to import memory blocks without copying them to the rented buffer. For instance, a memory block represented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.readonlymemory-1">ReadOnlyMemory&lt;T&gt;</a> can be intermixed with the memory blocks rented by the sparse buffer internally.</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using System;

var array = new byte[] { 10, 20, 30 };
using var writer = new SparseBufferWriter&lt;byte&gt;();
writer.Write(array.AsMemory(), false);  // false means that the memory block must be inserted into sparse buffer as-is without copying its content to the internal buffer
</code></pre>
<p>Sparse buffer writer also implements <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;T&gt;</a> interface as well as other buffer writers mentioned above. However, this interface is implemented explicitly and its methods should be used with care. Major drawback of this buffer type is that it can produce memory holes, i.e. unused memory segments in the middle of the buffer chunks. The holes can be caused by <code>IBufferWriter&lt;T&gt;.GetMemory(int)</code> or <code>IBufferWriter&lt;T&gt;.GetSpan(int)</code> implementations. Therefore these methods are implemented explicitly. All other public methods of <code>SparseBufferWriter&lt;T&gt;</code> class cannot cause memory holes.</p>
<p>Suppose that sparse buffer has rented memory block of size <em>1024</em> bytes, and <em>1000</em> bytes of them already occupied. If you want to write a block of size <em>100</em> bytes represented by <a href="https://docs.microsoft.com/en-us/dotnet/api/system.readonlyspan-1">ReadOnlySpan&lt;T&gt;</a> then use <code>SparseBufferWriter&lt;T&gt;.Write(ReadOnlySpan&lt;T&gt;)</code> method. It writes the first <em>24</em> bytes to the existing memory block and then rents a new segment to store the rest of the input buffer, <em>76</em> bytes. Therefore, <code>Write</code> method cannot cause fragmentation of memory blocks. However, if we want to obtain a memory block for writing via <code>GetMemory(int)</code> method then sparse buffer cannot utilize <em>24</em> bytes of free memory from the existing chunk because the returned buffer must be at least <em>100</em> bytes of contiguous memory. In this case, sparse buffer rents a new chunk with the size of at least <em>100</em> bytes and marks <em>24</em> bytes from the previous chunk as unused.</p>
<p>The implementation of <code>GetMemory(int)</code> and <code>GetSpan(int)</code> methods are optimized to reduce the number of such memory holes. However, due to nature of sparse buffer data structure, it is not possible in 100% cases. Nevertheless, such overhead can be acceptable because sparse buffer never reallocates the existing memory and may work faster than <a class="xref" href="../../api/DotNext.Buffers.PoolingBufferWriter-1.html">PoolingBufferWriter&lt;T&gt;</a> which requires reallocation when rented memory block is not enough to place a new data.</p>
<p>Additionally, you can use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">Stream</a>-based API to read from or write to the sparse buffer. <a class="xref" href="../../api/DotNext.IO.StreamSource.html">StreamSource</a> provides <code>AsStream</code> extension method that can be used to create readable or writable stream over the buffer:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using DotNext.IO;

using var buffer = new SparseBufferWriter&lt;byte&gt;();
using Stream writable = buffer.AsStream(false); // create writable stream
using Stream readable = buffer.AsStream(true);  // create readable stream
</code></pre>
<p>Sparse buffer supports various strategies for allocation of the memory chunks:</p>
<ol>
<li>Default behavior when size of each memory chunk is the same</li>
<li>Linear growth, when the size of each new memory chunk is a multiple of the chunk index</li>
<li>Exponential growth, when each new memory chunk doubles in size</li>
</ol>
<p>The first strategy is effective when potential max size of the resulting buffer is hundreds of elements and volatility is small. The last two are effective when max size of the result buffer can be potentially large (kilobytes) and volatility is unpredictable.</p>
<p>The following example demonstrates usage of exponential growth strategy with predefined size of initial memory chunk:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

using var buffer = new SparseBufferWriter&lt;byte&gt;(256, SparseBufferGrowth.Exponential);
</code></pre>
<h1 id="bufferwriterslim">BufferWriterSlim</h1>
<p><a class="xref" href="../../api/DotNext.Buffers.BufferWriterSlim-1.html">BufferWriterSlim&lt;T&gt;</a> is a lightweight version of <a class="xref" href="../../api/DotNext.Buffers.PoolingBufferWriter-1.html">PoolingBufferWriter&lt;T&gt;</a> class with its own unique features. The instance of writer always allocated on the stack because the type is declared as ref-like value type. Additionally, the writer allows to use stack-allocated memory for placing new elements.</p>
<p>If initial buffer overflows then <code>BufferWriterSlim&lt;T&gt;</code> obtains rented buffer from the pool and copies the initial buffer into it.</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

using var builder = new BufferWriterSlim&lt;byte&gt;(stackalloc byte[128]); // capacity can be changed at runtime
builder.Write(new byte[] { 1, 2, 3 });
ReadOnlySpan&lt;byte&gt; result = builder.WrittenSpan;
</code></pre>
<p>This type has the following limitations:</p>
<ul>
<li>Incompatible with async methods</li>
<li>Focused on <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span&lt;T&gt;</a> data type, there is no interop with types from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic">System.Collections.Generic</a> namespace.</li>
</ul>
<h1 id="char-buffer">Char Buffer</h1>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.stringbuilder">StringBuilder</a> is a great tool from .NET standard library to construct strings dynamically. However, it uses heap-based allocation of chunks and increases GC workload. The solution is to use pooled memory for growing buffer and release it when no longer needed. This approach is implemented by <code>PoolingBufferWriter&lt;T&gt;</code>, <code>PoolingArrayBufferWriter&lt;T&gt;</code>, <code>SparseBufferWriter&lt;T&gt;</code> and <code>BufferWriterSlim&lt;T&gt;</code> types as described above. But we need suitable methods for adding characters to the builder similar to the methods of <code>StringBuilder</code>. They are provided as extension methods declared in <a class="xref" href="../../api/DotNext.Buffers.BufferWriter.html">BufferWriter</a> class for all objects implementing <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;char&gt;</a> interface:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

using var writer = new PoolingArrayBufferWriter&lt;char&gt;(ArrayPool&lt;char&gt;.Shared);
writer.Write(&quot;Hello,&quot;);
writer.Write(' ');
writer.Write(&quot;world!&quot;);
writer.WriteLine();
writer.Format(2);
writer.Write('+');
writer.Format(2);
writer.Write('=');
writer.Format(4);

string result = writer.ToString();
</code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.textwriter">TextWriter</a> is a common way to produce text dynamically and recognizable by many third-party libraries. There is a bridge that allow to use TextWriter API over pooled buffer writer with help of extension methods declared in <a class="xref" href="../../api/DotNext.IO.TextStreamExtensions.html">TextStreamExtensions</a> class:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;
using System.IO;
using static DotNext.IO.TextWriterExtensions;

using var buffer = new PoolingArrayBufferWriter&lt;char&gt;(ArrayPool&lt;char&gt;.Shared);
using TextWriter writer = buffer.AsTextWriter();
writer.Write(&quot;Hello,&quot;);
writer.Write(' ');
writer.Write(&quot;world!&quot;);
writer.WriteLine();
writer.Write(2);
writer.Write('+');
writer.Write(2);
writer.Write('=');
writer.Write(4);

string result = buffer.ToString();
</code></pre>
<p>C# 10 introduces a new implementation of <a href="https://devblogs.microsoft.com/dotnet/string-interpolation-in-c-10-and-net-6/">string interpolation</a> using Interpolated String Handlers. This approach is fully supported by <code>WriteString</code> extension methods for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1">IBufferWriter&lt;char&gt;</a> and <a class="xref" href="../../api/DotNext.Buffers.BufferWriterSlim-1.html">BufferWriterSlim&lt;char&gt;</a> data types. Now string building can have zero memory allocation overhead:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

int x = 10, y = 20;
using var buffer = new BufferWriterSlim&lt;char&gt;(stackalloc char[128]);
buffer.Interpolate($&quot;{x} + {y} = {x + y}&quot;);

string result = buffer.ToString();
</code></pre>
<p>Alignment and custom formats are fully supported. For more information about these interpolated string handlers, see <a href="xref:DotNext.Buffers.BufferWriterSlimInterpolatedStringHandler">BufferWriterSlimInterpolatedStringHandler</a>, <a href="xref:DotNext.Buffers.BufferWriterInterpolatedStringHandler">BufferWriterInterpolatedStringHandler</a>, and <a href="xref:DotNext.Buffers.PoolingInterpolatedStringHandler">PoolingInterpolatedStringHandler</a> data types.</p>
<p><a class="xref" href="../../api/DotNext.Buffers.CharBuffer.html">CharBuffer</a> class offers extension methods for efficient concatenation of strings:</p>
<pre><code class="lang-csharp">using DotNext.Buffers;

int x = 10, y = 20;
using var buffer = new BufferWriterSlim&lt;char&gt;(stackalloc char[128]);
buffer.Concat([&quot;Hello,&quot;, &quot; &quot;, &quot;world!&quot;]);
</code></pre>
<h1 id="how-to-choose">How to choose?</h1>
<p>The following table describes the main differences between various growable buffer types:</p>
<table>
<thead>
<tr>
<th>Buffer Writer</th>
<th>When to use</th>
<th>Compatible with async methods</th>
<th>Space complexity (write operation)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PoolingArrayBufferWriter&lt;T&gt;</code></td>
<td>General applicability when initial capacity is known</td>
<td>Yes</td>
<td>o(1), O(n)</td>
</tr>
<tr>
<td><code>PoolingBufferWriter&lt;T&gt;</code></td>
<td>If custom <a class="xref" href="../../api/DotNext.Buffers.MemoryAllocator-1.html">memory allocator</a> is required. For instance, if you want to use <a class="xref" href="../../api/DotNext.Buffers.UnmanagedMemoryPool-1.html">unmanaged memory pool</a></td>
<td>Yes</td>
<td>o(1), O(n)</td>
</tr>
<tr>
<td><code>BufferWriterSlim&lt;T&gt;</code></td>
<td>If you have knowledge about optimal size of initial buffer which can be allocated on the stack. In this case the writer allows to avoid renting the buffer and doesn't allocate itself on the managed heap</td>
<td>No</td>
<td>o(1), O(n)</td>
</tr>
<tr>
<td><code>SparseBufferWriter&lt;T&gt;</code></td>
<td>If optimal size of initial buffer is not known and the length of the written data varies widely</td>
<td>Yes</td>
<td>o(1), O(1)</td>
</tr>
</tbody>
</table>
<p><code>SparseBufferWriter&lt;T&gt;</code> is more reusable than <a href="https://www.nuget.org/packages/Microsoft.IO.RecyclableMemoryStream/">RecyclableMemoryStream</a> because it can be instantiated with any generic argument, not only with <strong>byte</strong>. Moreover, the <a href="../../benchmarks.html">benchmark</a> demonstrates the better results for large memory blocks.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/io/buffers.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
