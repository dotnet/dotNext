<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Miscellaneous Statements | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Miscellaneous Statements | .NEXT ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="miscellaneous-statements">Miscellaneous Statements</h1>

<h1 id="writeline-expression">WriteLine Expression</h1>
<p><a class="xref" href="../../api/DotNext.Linq.Expressions.WriteLineExpression.html">WriteLineExpression</a> can be used to write line of the text in dynamically generated code. This expression supports several outputs for the text:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.console.out">Standard Output Stream</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.console.error">Standard Error Stream</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.debug.writeline#System_Diagnostics_Debug_WriteLine_System_Object_">Debug Output</a></li>
</ul>
<p>Additionally, Code Generator has static methods <code>WriteLine</code>, <code>WriteError</code> and <code>DebugMessage</code> that allow to place this expression as statement into lexical scope.</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="assertion">Assertion</h1>
<p>Checks for a condition; if the condition is false, outputs messages and displays a message box that shows the call stack. This statement is available as static method <code>Assert</code> from Code Generator only.</p>
<p>The statement is relevant in DEBUG configuration only. In any other configurations, <code>Assert</code> method is ignored.</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Assert(fun.IsNotNull(), &quot;Argument is null&quot;);
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="breakpoint">Breakpoint</h1>
<p>Signals a breakpoint to an attached debugger. This statement is available as static method <code>Breakpoint</code> from Code Generator only.</p>
<p>The statement is relevant in DEBUG configuration only. In any other configurations, <code>Breakpoint</code> method is ignored.</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;
using static DotNext.Metaprogramming.CodeGenerator;

var println = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Breakpoint();
	WriteLine(fun[0]);
});
</code></pre>
<h1 id="fragment">Fragment</h1>
<p>Regardless for rich set of helper methods for generating statements and expressions the code written for dynamic code generation may hard to read by developers. It reasonable to simplify construction of compound expressions or statements somehow. C# programming language supports creation of expression tree from single-line expression. This feature is utilized by Metaprogramming library and called <strong>expression fragment</strong>. The fragment is a body of lambda expression with parameters replaced by actual expressions from the context. It can be embedded as statement inside of multi-line lambda expression.</p>
<p>The following example demonstrates how to generate expression fragment:</p>
<pre><code class="lang-csharp">using DotNext.Linq.Expressions;
using System;

var fragment = ExpressionBuilder.Fragment&lt;Func&lt;int, int, int&gt;&gt;((x, y) =&gt; Math.Max(x, y), 10, 20);
//fragment is MethodCallExpression with two arguments: constant values 10 and 20 of type int
</code></pre>
<p>Static method <code>Embed</code> from Code Generator can be used to embed the expression fragment as statement into lexical scope of the multi-line lambda expression:</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var greeting = Lambda&lt;Action&lt;string&gt;&gt;(fun =&gt;
{
	Embed&lt;Action&lt;string&gt;&gt;(str =&gt; Console.WriteLine(&quot;Hello, {0}&quot;, str), fun[0]);
});

// the generated code is

new Action&lt;string&gt;(str =&gt; Console.WriteLine(&quot;Hello, {0}&quot;, str)));
</code></pre>
<h1 id="statement">Statement</h1>
<p>Migration of third-party code from plain <em>Expression Trees</em> to .NEXT Metaprogramming can be challenging due to differences in programming model. The code based on <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expression">Expression</a> class implements construction of expression trees. The code based on <code>CodeGenerator</code> class implements natural flow of the code: each call of static method represents a single statement. <code>CodeGenerator.Statement</code> static method bridges the gap between two programming model and simplifies code migration:</p>
<pre><code class="lang-csharp">using System;
using static DotNext.Metaprogramming.CodeGenerator;

var greeting = Lambda&lt;Func&lt;int, int, int&gt;&gt;(fun =&gt;
{
	Statement(Expression.Add(fun[0], fun[1]));
});

// the generated code is
new Func&lt;int, int, int&gt;((x, y) =&gt; x + y);
</code></pre>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/metaprogramming/misc.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">☀</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">☾</i>
                </div>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">☀</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">☾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
