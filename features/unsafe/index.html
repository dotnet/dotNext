<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Unsafe Data Structures | .NEXT </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Unsafe Data Structures | .NEXT ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../../fav.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../doc_logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="unsafe-data-structures">Unsafe Data Structures</h1>

<p>Historically, .NET Runtime was oriented to work with managed memory where Garbage Collector provides automatic memory management. The object placed into managed heap is reclaimed automatically when no longer needed. But numerous instantiation of thousand objects leads to GC pressure and may affect application performance. Manual memory management in some situations may fix this issue.</p>
<p>.NET provides a lot of interop services to call external native C libraries or COM objects. Moreover, the standard library provides a way to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal">allocate unmanaged memory</a> outside of managed heap. But there is no routines for unmanaged memory manipulation. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe">Unsafe</a>, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.memorypool-1">MemoryPool</a> are not equal to C memory functions and oriented to managed memory manipulation. <code>Span</code> value type has special syntactic support in C# when stack allocated memory can be wrapped into this type:</p>
<pre><code class="lang-csharp">Span&lt;int&gt; s = stackalloc int[4];
</code></pre>
<p>.NEXT library provides rich data structures allocated in unmanaged heap (off-heap memory) and set of routines comparable to C memory functions. Moreover, these features are platform and hardware independent.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The library is written in managed code without PInvoke calls.</p>
</div>
<p>The first feature is CLS compliant pointer data type with low-level memory manipulation methods. The second feature is a set of value types representing structured access to the off-heap memory:</p>
<ol>
<li><a class="xref" href="../../api/DotNext.Buffers.UnmanagedMemoryPool-1.html">UnmanagedMemoryPool&lt;T&gt;</a> provides allocation of unmanaged memory</li>
<li><a class="xref" href="../../api/DotNext.Runtime.InteropServices.IUnmanagedMemory-1.html">IUnmanagedMemory&lt;T&gt;</a> provides structured access to the allocated unmanaged memory.</li>
</ol>
<p>All unmanaged data types are not thread-safe.</p>
<p><code>IUnmanagedMemory&lt;T&gt;</code>derives from <a class="xref" href="../../api/DotNext.Runtime.InteropServices.IUnmanagedMemory.html">IUnmanagedMemory</a> and supports direct memory manipulations:</p>
<ul>
<li><code>Pointer</code> property provides flexible manipulations using typed pointer to the memory. It is unsafe way because the pointer doesn't provide bound checks</li>
<li><code>Bytes</code> property provides memory access using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1">Span</a> data type. It is less flexible in comparison with pointer but safe because it implements bound checks</li>
</ul>
<h1 id="pointer">Pointer</h1>
<p>C# programming language supports typed and untyped pointer data types such as <em>int*</em> or <em>void*</em>. These types are not CLS-compliant and may not be available in other .NET programming languages. For instance, F# or VB.NET do not support pointer type and interoperation with native libraries or COM objects are limited.</p>
<p>.NEXT offers <a class="xref" href="../../api/DotNext.Runtime.InteropServices.Pointer-1.html">Pointer&lt;T&gt;</a> value type which is CLS-compliant typed pointer. This type supports pointer arithmetic as well as rich methods for memory manupulations such as copying, swapping, filling with zeroes, comparison and equality check. These methods are equivalent to C memory functions: <code>memset</code>, <code>memcmp</code> etc. Additionally, there are routines to copying bytes to/from the unmanaged memory from/to the arbitrary <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream">streams</a> asynchronously. Check out API documentation for detailed information about available methods.</p>
<p>The pointer data type is convertible to/from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.intptr">native int</a> so it can be used to simplify interoperation with native code. The size of the pointer depends on underlying platform.</p>
<p>The following example demonstrates usage of the typed pointer to work with stack-allocated memory:</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;
using System.IO;

private static void UnsafeMethod()
{
    Pointer&lt;int&gt; ptr = stackalloc int[4] { 1, 3, 6, 9 };
    ptr.Value = 10; //change value 1 to 10
    ptr += 2;   //pointer arithmetic. Now pointer points to the third element in stack-allocated array
    ptr.Value = 50; //change value 6 to 50
    //copy to stream
    using(Stream memory = new MemoryStream())
    {
        ptr.WriteTo(memory, 4);
    }
    //copy to array
    var array = new int[4];
    ptr.WriteTo(array); //now array = new int[] { 10, 3, 50, 9 }
}
</code></pre>
<p>Pointer can be re-interpreted:</p>
<pre><code class="lang-csharp">using DotNext.Runtime.InteropServices;

private static void UnsafeMethod()
{
    Pointer&lt;int&gt; ptr = stackalloc int[4] { 1, 3, 6, 9 };

    Pointer&lt;uint&gt; uptr = ptr.As&lt;uint&gt;();
}
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Typed pointer doesn't provide range checks.</p>
</div>
<p>Volatile operations are fully supported by pointer:</p>
<pre><code class="lang-csharp">using System.Threading;
using DotNext.Runtime.InteropServices;
using DotNext.Threading;

Pointer&lt;long&gt; ptr;
Volatile.Write(ref ptr.Value, 42L);
var i = Volatile.Read(in ptr.Value);
i = Interlocked.Increment(ref ptr.Value); //i == 43
</code></pre>
<h1 id="system-pages">System Pages</h1>
<p><a class="xref" href="../../api/DotNext.Buffers.UnmanagedMemory.html">UnmanagedMemory</a> class exposes static methods to allocate system pages or page-aligned memory blocks in safe and portable manner. The returned memory is represented by the object that implements <a href="https://learn.microsoft.com/en-us/dotnet/api/system.buffers.imemoryowner-1">IMemoryOwner&lt;T&gt;</a> interface. Thus, the allocated memory can be easily used across .NET ecosystem:</p>
<pre><code class="lang-csharp">// allocates 3 pages. Typically, the page size is 4k bytes
using IMemoryOwner&lt;byte&gt; pages = UnmanagedMemory.AllocateSystemPages(3);
Span&lt;byte&gt; span = pages.Memory.Span;
</code></pre>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/dotNext/blob/gh-pages/docs/features/unsafe/index.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <div class="toggle-mode">
                <div class="icon">
                  <i aria-hidden="true">â˜€</i>
                </div>
                <label class="switch">
                  <input type="checkbox" id="switch-style">
                  <span class="slider round"></span>
                </label>
                <div class="icon">
                  <i aria-hidden="true">â˜¾</i>
                </div>
              </div>

              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <h5>In this article</h5>
              <div></div>
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            <div class="pull-left">
        Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>
        
            </div>
            <div class="toggle-mode pull-right visible-sm visible-xs">
              <div class="icon">
                <i aria-hidden="true">â˜€</i>
              </div>
              <label class="switch">
                <input type="checkbox" id="switch-style-m">
                <span class="slider round"></span>
              </label>
              <div class="icon">
                <i aria-hidden="true">â˜¾</i>
              </div>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="../../styles/toggle-theme.js"></script>
      </footer>    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
